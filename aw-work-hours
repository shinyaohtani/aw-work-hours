#!/usr/bin/env python3
"""
ActivityWatchから日ごとの勤務時間をCSVにエクスポートするコマンド

Usage:
    aw-work-hours                    # 今月の勤務時間を出力
    aw-work-hours --month=last       # 先月の勤務時間を出力
    aw-work-hours --month=2025-11    # 2025年11月の勤務時間を出力
    aw-work-hours --month=all        # 全期間の勤務時間を出力

勤務日の判定ルール:
- 継続している勤務は何時までも同じ日として扱う
- 5:00-8:00の間に新たに開始した勤務は新しい日として扱う
- 24:00をまたいだ場合は26:00のような表記にする
"""

import argparse
import json
import sys
import urllib.request
import urllib.error
import urllib.parse
from datetime import datetime, timedelta, date
from zoneinfo import ZoneInfo

_API_BASE: str = "http://127.0.0.1:5600/api/0"
_BUCKET_ID: str = "aw-watcher-afk_PC-MC2408N0009B.local"
_TIMEZONE: ZoneInfo = ZoneInfo("Asia/Tokyo")
_WORK_GAP_SECONDS: int = 3 * 60 * 60
_WEEKDAYS: list[str] = ["月", "火", "水", "木", "金", "土", "日"]


class MonthPeriod:
    """月の期間"""

    def __init__(self, start: datetime | None, end: datetime | None) -> None:
        self._start: datetime | None = start
        self._end: datetime | None = end

    @classmethod
    def parse(cls, month_str: str) -> "MonthPeriod":
        now: datetime = datetime.now(_TIMEZONE)
        if month_str == "this":
            return cls._this_month(now)
        elif month_str == "last":
            return cls._last_month(now)
        elif month_str == "all":
            return cls(None, None)
        else:
            return cls._specified_month(month_str)

    @classmethod
    def _this_month(cls, now: datetime) -> "MonthPeriod":
        start: datetime = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        if now.month == 12:
            end: datetime = start.replace(year=now.year + 1, month=1)
        else:
            end = start.replace(month=now.month + 1)
        return cls(start, end)

    @classmethod
    def _last_month(cls, now: datetime) -> "MonthPeriod":
        first: datetime = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        if now.month == 1:
            start: datetime = first.replace(year=now.year - 1, month=12)
        else:
            start = first.replace(month=now.month - 1)
        return cls(start, first)

    @classmethod
    def _specified_month(cls, month_str: str) -> "MonthPeriod":
        try:
            year, month = map(int, month_str.split("-"))
            start: datetime = datetime(year, month, 1, tzinfo=_TIMEZONE)
            if month == 12:
                end: datetime = start.replace(year=year + 1, month=1)
            else:
                end = start.replace(month=month + 1)
            return cls(start, end)
        except ValueError:
            print(f"エラー: 無効な月指定です: {month_str}", file=sys.stderr)
            print("使用可能な形式: this, last, all, YYYY-MM (例: 2025-11)", file=sys.stderr)
            sys.exit(1)

    @property
    def start(self) -> str | None:
        return self._start.isoformat() if self._start else None

    @property
    def end(self) -> str | None:
        return self._end.isoformat() if self._end else None

    @property
    def start_date(self) -> date | None:
        return self._start.date() if self._start else None

    @property
    def end_date(self) -> date | None:
        return self._end.date() if self._end else None


class AFKEvents:
    """ActivityWatchのAFKイベント"""

    def __init__(self, events: list[dict]) -> None:
        self._events: list[dict] = events

    @classmethod
    def fetch(cls, start: str | None, end: str | None) -> "AFKEvents":
        url: str = cls._build_url(start, end)
        try:
            with urllib.request.urlopen(url, timeout=30) as response:
                events: list[dict] = json.loads(response.read().decode())
                return cls(events)
        except urllib.error.URLError as e:
            print("エラー: ActivityWatch APIに接続できません", file=sys.stderr)
            print("ActivityWatchが起動しているか確認してください", file=sys.stderr)
            print(f"詳細: {e}", file=sys.stderr)
            sys.exit(1)

    @classmethod
    def _build_url(cls, start: str | None, end: str | None) -> str:
        url: str = f"{_API_BASE}/buckets/{_BUCKET_ID}/events"
        params: dict[str, str] = {"limit": "-1"}
        if start:
            params["start"] = start
        if end:
            params["end"] = end
        return url + "?" + urllib.parse.urlencode(params)

    @property
    def count(self) -> int:
        return len(self._events)

    @property
    def work_blocks(self) -> list[tuple[datetime, datetime]]:
        not_afk: list[dict] = sorted(
            [e for e in self._events if e["data"]["status"] == "not-afk"],
            key=lambda e: e["timestamp"]
        )
        if not not_afk:
            return []
        return self._extract_blocks(not_afk)

    def _extract_blocks(self, events: list[dict]) -> list[tuple[datetime, datetime]]:
        blocks: list[tuple[datetime, datetime]] = []
        block_start: datetime | None = None
        block_end: datetime | None = None

        for event in events:
            event_start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(_TIMEZONE)
            event_end: datetime = event_start + timedelta(seconds=event["duration"])

            if block_start is None:
                block_start, block_end = event_start, event_end
            else:
                gap: float = (event_start - block_end).total_seconds()
                if gap > _WORK_GAP_SECONDS and event_start.hour >= 5:
                    blocks.append((block_start, block_end))
                    block_start, block_end = event_start, event_end
                else:
                    block_end = max(block_end, event_end)

        if block_start is not None:
            blocks.append((block_start, block_end))
        return blocks


class WorkCalendar:
    """勤務カレンダー"""

    def __init__(self, daily: dict[date, tuple[datetime, datetime]]) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily

    @classmethod
    def from_blocks(cls, blocks: list[tuple[datetime, datetime]]) -> "WorkCalendar":
        daily: dict[date, tuple[datetime, datetime]] = {}
        for block_start, block_end in blocks:
            work_date: date = cls._work_date(block_start)
            if work_date not in daily:
                daily[work_date] = (block_start, block_end)
            else:
                existing_start, existing_end = daily[work_date]
                daily[work_date] = (
                    min(block_start, existing_start),
                    max(block_end, existing_end)
                )
        return cls(daily)

    @classmethod
    def _work_date(cls, dt: datetime) -> date:
        if 0 <= dt.hour < 5:
            return (dt - timedelta(days=1)).date()
        return dt.date()

    @property
    def days(self) -> int:
        return len(self._daily)

    def csv(self) -> str:
        lines: list[str] = ["date,weekday,start_time,end_time,duration_hours"]
        for work_date in sorted(self._daily.keys()):
            start, end = self._daily[work_date]
            start_time: str = self._format_time(start, work_date)
            end_time: str = self._format_time(end, work_date)
            duration: float = (end - start).total_seconds() / 3600
            lines.append(
                f'="{work_date.strftime("%Y-%m-%d")}",'
                f'{_WEEKDAYS[work_date.weekday()]},'
                f'="{start_time}",="{end_time}",{duration:.2f}'
            )
        return "\n".join(lines) + "\n"

    def compact(self, period: MonthPeriod) -> str:
        today: date = datetime.now(_TIMEZONE).date()
        start, end = self._compact_range(period, today)
        if start is None:
            return ""
        return self._format_compact(start, end)

    def _compact_range(self, period: MonthPeriod, today: date) -> tuple[date | None, date | None]:
        if period.start_date and period.end_date:
            start: date = period.start_date
            end: date = min(period.end_date, today + timedelta(days=1))
        elif self._daily:
            start = min(self._daily.keys())
            end = max(self._daily.keys()) + timedelta(days=1)
        else:
            return None, None
        return start, end

    def _format_compact(self, start: date, end: date) -> str:
        lines: list[str] = []
        current: date = start
        while current < end:
            lines.append(self._format_day(current))
            current += timedelta(days=1)
        return "\n".join(lines) + "\n" if lines else ""

    def _format_day(self, d: date) -> str:
        prefix: str = f'{d.strftime("%Y-%m-%d")} {_WEEKDAYS[d.weekday()]}'
        if d not in self._daily:
            return prefix
        start, end = self._daily[d]
        duration: float = (end - start).total_seconds() / 3600
        if round(duration, 1) == 0:
            return prefix
        start_time: str = self._format_time(start, d)
        end_time: str = self._format_time(end, d)
        return f'{prefix}   {start_time} - {end_time}   ({duration:.1f}h)'

    def _format_time(self, dt: datetime, base: date) -> str:
        days_diff: int = (dt.date() - base).days
        hour: int = dt.hour + (days_diff * 24)
        return f"{hour:02d}:{dt.minute:02d}"


class CLI:
    """コマンドラインインターフェース"""

    def run(self) -> None:
        args: argparse.Namespace = self._args()
        period: MonthPeriod = MonthPeriod.parse(args.month)

        self._status(f"対象期間: {self._period_label(args.month)}", args.quiet)
        self._status("ActivityWatchからデータを取得中...", args.quiet)

        events: AFKEvents = AFKEvents.fetch(period.start, period.end)
        self._status(f"取得イベント数: {events.count}", args.quiet)

        calendar: WorkCalendar = WorkCalendar.from_blocks(events.work_blocks)
        self._status(f"勤務日数: {calendar.days}", args.quiet)

        self._output(calendar, period, args)

    def _args(self) -> argparse.Namespace:
        parser: argparse.ArgumentParser = argparse.ArgumentParser(
            description="ActivityWatchから勤務時間をCSVにエクスポート",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
例:
  aw-work-hours                    今月の勤務時間を出力
  aw-work-hours --month=last       先月の勤務時間を出力
  aw-work-hours --month=2025-11    2025年11月の勤務時間を出力
  aw-work-hours --month=all        全期間の勤務時間を出力
  aw-work-hours -o work.csv        ファイルに出力
"""
        )
        parser.add_argument("--month", "-m", default="this",
                            help="対象月: this(今月), last(先月), all(全期間), YYYY-MM")
        parser.add_argument("--output", "-o", help="出力ファイル名")
        parser.add_argument("--quiet", "-q", action="store_true", help="進捗非表示")
        return parser.parse_args()

    def _status(self, msg: str, quiet: bool) -> None:
        if not quiet:
            print(msg, file=sys.stderr)

    def _period_label(self, month: str) -> str:
        labels: dict[str, str] = {"all": "全期間", "this": "今月", "last": "先月"}
        return labels.get(month, month)

    def _output(self, calendar: WorkCalendar, period: MonthPeriod, args: argparse.Namespace) -> None:
        if args.output:
            with open(args.output, "w", encoding="utf-8-sig") as f:
                f.write(calendar.csv())
            self._status(f"出力完了: {args.output}", args.quiet)
        else:
            print(calendar.compact(period), end="")


if __name__ == "__main__":
    CLI().run()
