#!/usr/bin/env python3
"""
ActivityWatchから日ごとの勤務時間をCSVにエクスポートするコマンド

Usage:
    aw-work-hours                    # 今月の勤務時間を出力
    aw-work-hours --month=last       # 先月の勤務時間を出力
    aw-work-hours --month=2025-11    # 2025年11月の勤務時間を出力
    aw-work-hours --month=all        # 全期間の勤務時間を出力

勤務日の判定ルール:
- 継続している勤務は何時までも同じ日として扱う
- 5:00-8:00の間に新たに開始した勤務は新しい日として扱う
- 24:00をまたいだ場合は26:00のような表記にする
"""

import argparse
import json
import sys
import urllib.request
import urllib.error
import urllib.parse
from datetime import datetime, timedelta, date
from zoneinfo import ZoneInfo

_API_BASE: str = "http://127.0.0.1:5600/api/0"
_BUCKET_ID: str = "aw-watcher-afk_PC-MC2408N0009B.local"
_TIMEZONE: ZoneInfo = ZoneInfo("Asia/Tokyo")
_WORK_GAP_SECONDS: int = 3 * 60 * 60
_WEEKDAYS: list[str] = ["月", "火", "水", "木", "金", "土", "日"]


class MonthPeriod:
    """月の期間"""

    def __init__(self, start: datetime | None, end: datetime | None) -> None:
        self._start: datetime | None = start
        self._end: datetime | None = end

    @classmethod
    def parse(cls, month_str: str) -> "MonthPeriod":
        now: datetime = datetime.now(_TIMEZONE)
        first: datetime = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)

        if month_str == "this":
            end: datetime = first.replace(year=first.year + 1, month=1) if now.month == 12 else first.replace(month=now.month + 1)
            return cls(first, end)
        elif month_str == "last":
            start: datetime = first.replace(year=first.year - 1, month=12) if now.month == 1 else first.replace(month=now.month - 1)
            return cls(start, first)
        elif month_str == "all":
            return cls(None, None)
        else:
            try:
                year, month = map(int, month_str.split("-"))
                start = datetime(year, month, 1, tzinfo=_TIMEZONE)
                end = start.replace(year=year + 1, month=1) if month == 12 else start.replace(month=month + 1)
                return cls(start, end)
            except ValueError:
                print(f"エラー: 無効な月指定です: {month_str}", file=sys.stderr)
                print("使用可能な形式: this, last, all, YYYY-MM (例: 2025-11)", file=sys.stderr)
                sys.exit(1)

    @property
    def start(self) -> str | None:
        return self._start.isoformat() if self._start else None

    @property
    def end(self) -> str | None:
        return self._end.isoformat() if self._end else None

    @property
    def start_date(self) -> date | None:
        return self._start.date() if self._start else None

    @property
    def end_date(self) -> date | None:
        return self._end.date() if self._end else None


class AFKEvents:
    """ActivityWatchのAFKイベント"""

    def __init__(self, events: list[dict]) -> None:
        self._events: list[dict] = events

    @classmethod
    def fetch(cls, start: str | None, end: str | None) -> "AFKEvents":
        url: str = f"{_API_BASE}/buckets/{_BUCKET_ID}/events"
        params: dict[str, str] = {"limit": "-1"}
        if start:
            params["start"] = start
        if end:
            params["end"] = end
        url += "?" + urllib.parse.urlencode(params)

        try:
            with urllib.request.urlopen(url, timeout=30) as response:
                return cls(json.loads(response.read().decode()))
        except urllib.error.URLError as e:
            print("エラー: ActivityWatch APIに接続できません", file=sys.stderr)
            print("ActivityWatchが起動しているか確認してください", file=sys.stderr)
            print(f"詳細: {e}", file=sys.stderr)
            sys.exit(1)

    @property
    def count(self) -> int:
        return len(self._events)

    @property
    def work_blocks(self) -> list[tuple[datetime, datetime]]:
        not_afk: list[dict] = sorted(
            [e for e in self._events if e["data"]["status"] == "not-afk"],
            key=lambda e: e["timestamp"]
        )
        return self._extract_blocks(not_afk) if not_afk else []

    def _extract_blocks(self, events: list[dict]) -> list[tuple[datetime, datetime]]:
        blocks: list[tuple[datetime, datetime]] = []
        block_start: datetime | None = None
        block_end: datetime | None = None

        for event in events:
            event_start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(_TIMEZONE)
            event_end: datetime = event_start + timedelta(seconds=event["duration"])

            if block_start is None:
                block_start, block_end = event_start, event_end
            else:
                gap: float = (event_start - block_end).total_seconds()
                if gap > _WORK_GAP_SECONDS and event_start.hour >= 5:
                    blocks.append((block_start, block_end))
                    block_start, block_end = event_start, event_end
                else:
                    block_end = max(block_end, event_end)

        if block_start is not None:
            blocks.append((block_start, block_end))
        return blocks


class WorkCalendar:
    """勤務カレンダー"""

    def __init__(self, daily: dict[date, tuple[datetime, datetime]]) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily

    @classmethod
    def from_blocks(cls, blocks: list[tuple[datetime, datetime]]) -> "WorkCalendar":
        daily: dict[date, tuple[datetime, datetime]] = {}
        for block_start, block_end in blocks:
            work_date: date = (block_start - timedelta(days=1)).date() if 0 <= block_start.hour < 5 else block_start.date()
            if work_date not in daily:
                daily[work_date] = (block_start, block_end)
            else:
                s, e = daily[work_date]
                daily[work_date] = (min(block_start, s), max(block_end, e))
        return cls(daily)

    @property
    def days(self) -> int:
        return len(self._daily)

    def csv(self) -> str:
        lines: list[str] = ["date,weekday,start_time,end_time,duration_hours"]
        for work_date in sorted(self._daily.keys()):
            start, end = self._daily[work_date]
            duration: float = (end - start).total_seconds() / 3600
            lines.append(
                f'="{work_date.strftime("%Y-%m-%d")}",{_WEEKDAYS[work_date.weekday()]},'
                f'="{self._format_time(start, work_date)}",="{self._format_time(end, work_date)}",{duration:.2f}'
            )
        return "\n".join(lines) + "\n"

    def compact(self, period: MonthPeriod) -> str:
        today: date = datetime.now(_TIMEZONE).date()
        if period.start_date and period.end_date:
            start, end = period.start_date, min(period.end_date, today + timedelta(days=1))
        elif self._daily:
            start, end = min(self._daily.keys()), max(self._daily.keys()) + timedelta(days=1)
        else:
            return ""

        lines: list[str] = []
        current: date = start
        while current < end:
            prefix: str = f'{current.strftime("%Y-%m-%d")} {_WEEKDAYS[current.weekday()]}'
            if current in self._daily:
                s, e = self._daily[current]
                duration: float = (e - s).total_seconds() / 3600
                if round(duration, 1) != 0:
                    prefix = f'{prefix}   {self._format_time(s, current)} - {self._format_time(e, current)}   ({duration:.1f}h)'
            lines.append(prefix)
            current += timedelta(days=1)
        return "\n".join(lines) + "\n" if lines else ""

    def _format_time(self, dt: datetime, base: date) -> str:
        hour: int = dt.hour + ((dt.date() - base).days * 24)
        return f"{hour:02d}:{dt.minute:02d}"


class CLI:
    """コマンドラインインターフェース"""

    def run(self) -> None:
        args: argparse.Namespace = self._args()
        period: MonthPeriod = MonthPeriod.parse(args.month)
        labels: dict[str, str] = {"all": "全期間", "this": "今月", "last": "先月"}

        self._status(f"対象期間: {labels.get(args.month, args.month)}", args.quiet)
        self._status("ActivityWatchからデータを取得中...", args.quiet)

        events: AFKEvents = AFKEvents.fetch(period.start, period.end)
        self._status(f"取得イベント数: {events.count}", args.quiet)

        calendar: WorkCalendar = WorkCalendar.from_blocks(events.work_blocks)
        self._status(f"勤務日数: {calendar.days}", args.quiet)

        self._output(calendar, period, args)

    def _args(self) -> argparse.Namespace:
        p: argparse.ArgumentParser = argparse.ArgumentParser(
            description="ActivityWatchから勤務時間をCSVにエクスポート",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="例:\n  aw-work-hours                    今月の勤務時間を出力\n"
                   "  aw-work-hours --month=last       先月の勤務時間を出力\n"
                   "  aw-work-hours --month=2025-11    2025年11月の勤務時間を出力\n"
                   "  aw-work-hours --month=all        全期間の勤務時間を出力\n"
                   "  aw-work-hours -o work.csv        ファイルに出力"
        )
        p.add_argument("--month", "-m", default="this", help="対象月: this(今月), last(先月), all(全期間), YYYY-MM")
        p.add_argument("--output", "-o", help="出力ファイル名")
        p.add_argument("--quiet", "-q", action="store_true", help="進捗非表示")
        return p.parse_args()

    def _status(self, msg: str, quiet: bool) -> None:
        if not quiet:
            print(msg, file=sys.stderr)

    def _output(self, calendar: WorkCalendar, period: MonthPeriod, args: argparse.Namespace) -> None:
        if args.output:
            with open(args.output, "w", encoding="utf-8-sig") as f:
                f.write(calendar.csv())
            self._status(f"出力完了: {args.output}", args.quiet)
        else:
            print(calendar.compact(period), end="")


if __name__ == "__main__":
    CLI().run()
