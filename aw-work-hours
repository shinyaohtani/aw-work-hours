#!/usr/bin/env python3
"""
ActivityWatchから日ごとの勤務時間をCSVにエクスポートするコマンド

Usage:
    aw-work-hours                    # 今月の勤務時間を出力
    aw-work-hours --month=last       # 先月の勤務時間を出力
    aw-work-hours --month=2025-11    # 2025年11月の勤務時間を出力
    aw-work-hours --month=all        # 全期間の勤務時間を出力

勤務日の判定ルール:
- 継続している勤務は何時までも同じ日として扱う
- 5:00-8:00の間に新たに開始した勤務は新しい日として扱う
- 24:00をまたいだ場合は26:00のような表記にする
"""

import argparse
import http.server
import json
import socket
import ssl
import subprocess
import sys
import tempfile
import threading
import urllib.error
import urllib.parse
import urllib.request
from datetime import date, datetime, timedelta
from pathlib import Path
from zoneinfo import ZoneInfo

_API_BASE: str = "http://127.0.0.1:5600/api/0"
_TIMEZONE: ZoneInfo = ZoneInfo("Asia/Tokyo")
_WORK_GAP_SECONDS: int = 3 * 60 * 60
_WEEKDAYS: list[str] = ["月", "火", "水", "木", "金", "土", "日"]


class AFKBucketCandidates:
    """AFKバケットの候補群"""

    def __init__(self, afk_ids: list[str], preference: str | None) -> None:
        self._afk_ids: list[str] = afk_ids
        self._preference: str | None = preference

    @property
    def selected(self) -> str:
        if not self._afk_ids:
            print("エラー: AFKバケットが見つかりません", file=sys.stderr)
            print("aw-watcher-afkが有効か確認してください", file=sys.stderr)
            sys.exit(1)
        if self._preference:
            return self._by_preference()
        if len(self._afk_ids) == 1:
            return self._afk_ids[0]
        return self._by_latest()

    def _by_preference(self) -> str:
        matched: list[str] = [b for b in self._afk_ids if self._preference.lower() in b.lower()]
        if not matched:
            print(f"エラー: '{self._preference}' にマッチするバケットが見つかりません", file=sys.stderr)
            print("利用可能なバケット:", file=sys.stderr)
            for bid in self._afk_ids:
                print(f"  {bid.replace('aw-watcher-afk_', '')}", file=sys.stderr)
            sys.exit(1)
        if len(matched) > 1:
            print(f"エラー: '{self._preference}' に複数のバケットがマッチしました:", file=sys.stderr)
            for bid in matched:
                print(f"  {bid.replace('aw-watcher-afk_', '')}", file=sys.stderr)
            sys.exit(1)
        return matched[0]

    def _by_latest(self) -> str:
        ranked: list[tuple[str, datetime | None, str]] = []
        for bid in self._afk_ids:
            hostname: str = bid.replace("aw-watcher-afk_", "")
            ranked.append((bid, self._last_event(bid), hostname))
        ranked.sort(key=lambda x: x[1] or datetime.min.replace(tzinfo=_TIMEZONE), reverse=True)
        print("複数のAFKバケットが見つかりました（PC名ごとに記録が分かれています）:", file=sys.stderr)
        for i, (_, last, hostname) in enumerate(ranked):
            last_str: str = last.strftime("%Y-%m-%d %H:%M") if last else "データなし"
            marker: str = " ← 使用" if i == 0 else ""
            print(f"  {hostname}: 最終記録 {last_str}{marker}", file=sys.stderr)
        print("最新のデータを持つバケットを自動選択しました。", file=sys.stderr)
        print("特定のバケットを使う場合: --bucket=PC名", file=sys.stderr)
        return ranked[0][0]

    def _last_event(self, bucket_id: str) -> datetime | None:
        url: str = f"{_API_BASE}/buckets/{bucket_id}/events?limit=1"
        try:
            with urllib.request.urlopen(url, timeout=5) as resp:
                events: list = json.loads(resp.read().decode())
                if events:
                    return datetime.fromisoformat(events[0]["timestamp"]).astimezone(_TIMEZONE)
        except (urllib.error.URLError, KeyError, IndexError):
            pass
        return None


class AFKBucket:
    """ActivityWatchのAFKバケット"""

    _cached_id: str | None = None
    _preference: str | None = None

    @classmethod
    def set_preference(cls, hostname: str | None) -> None:
        cls._preference = hostname

    @classmethod
    def id(cls) -> str:
        if cls._cached_id:
            return cls._cached_id
        afk_ids: list[str] = cls._fetch_ids()
        cls._cached_id = cls._resolve(afk_ids)
        return cls._cached_id

    @classmethod
    def _fetch_ids(cls) -> list[str]:
        url: str = f"{_API_BASE}/buckets"
        try:
            with urllib.request.urlopen(url, timeout=10) as resp:
                buckets: dict = json.loads(resp.read().decode())
        except urllib.error.URLError as e:
            print("エラー: ActivityWatch APIに接続できません", file=sys.stderr)
            print("ActivityWatchが起動しているか確認してください", file=sys.stderr)
            print(f"詳細: {e}", file=sys.stderr)
            sys.exit(1)
        return [b for b in buckets if b.startswith("aw-watcher-afk_")]

    @classmethod
    def _resolve(cls, afk_ids: list[str]) -> str:
        candidates: AFKBucketCandidates = AFKBucketCandidates(afk_ids, cls._preference)
        return candidates.selected


class MonthPeriod:
    """月の期間"""

    def __init__(self, start: datetime | None, end: datetime | None) -> None:
        self._start: datetime | None = start
        self._end: datetime | None = end

    @classmethod
    def parse(cls, month_str: str) -> "MonthPeriod":
        if month_str == "all":
            return cls(None, None)
        year, month = cls._parse_year_month(month_str)
        start: datetime = datetime(year, month, 1, tzinfo=_TIMEZONE)
        end_year, end_month = (year + 1, 1) if month == 12 else (year, month + 1)
        end: datetime = datetime(end_year, end_month, 1, tzinfo=_TIMEZONE)
        return cls(start, end)

    @classmethod
    def _parse_year_month(cls, month_str: str) -> tuple[int, int]:
        now: datetime = datetime.now(_TIMEZONE)
        if month_str == "this":
            return now.year, now.month
        if month_str == "last":
            return (now.year - 1, 12) if now.month == 1 else (now.year, now.month - 1)
        try:
            year, month = map(int, month_str.split("-"))
            return year, month
        except ValueError:
            print(f"エラー: 無効な月指定です: {month_str}", file=sys.stderr)
            sys.exit(1)

    @property
    def iso(self) -> tuple[str | None, str | None]:
        return (
            self._start.isoformat() if self._start else None,
            self._end.isoformat() if self._end else None,
        )

    @property
    def dates(self) -> tuple[date | None, date | None]:
        return (
            self._start.date() if self._start else None,
            self._end.date() if self._end else None,
        )


class AFKEvents:
    """ActivityWatchのAFKイベント"""

    def __init__(self, events: list[dict]) -> None:
        self._events: list[dict] = events

    @classmethod
    def fetch(cls, start: str | None, end: str | None) -> "AFKEvents":
        url: str = f"{_API_BASE}/buckets/{AFKBucket.id()}/events"
        params: dict[str, str] = {"limit": "-1"}
        if start:
            params["start"] = start
        if end:
            params["end"] = end
        url += "?" + urllib.parse.urlencode(params)
        try:
            with urllib.request.urlopen(url, timeout=30) as resp:
                return cls(json.loads(resp.read().decode()))
        except urllib.error.URLError as e:
            print("エラー: ActivityWatch APIに接続できません", file=sys.stderr)
            print("ActivityWatchが起動しているか確認してください", file=sys.stderr)
            print(f"詳細: {e}", file=sys.stderr)
            sys.exit(1)

    @property
    def count(self) -> int:
        return len(self._events)

    @property
    def raw(self) -> list[dict]:
        return self._events

    @property
    def work_blocks(self) -> list[tuple[datetime, datetime]]:
        not_afk: list[dict] = sorted(
            [e for e in self._events if e["data"]["status"] == "not-afk" and e["duration"] >= 5],
            key=lambda e: e["timestamp"],
        )
        return self._extract_blocks(not_afk) if not_afk else []

    def _extract_blocks(self, events: list[dict]) -> list[tuple[datetime, datetime]]:
        blocks: list[tuple[datetime, datetime]] = []
        block_start: datetime | None = None
        block_end: datetime = datetime.min.replace(tzinfo=_TIMEZONE)
        for event in events:
            start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(_TIMEZONE)
            end: datetime = start + timedelta(seconds=event["duration"])
            if block_start is None:
                block_start, block_end = start, end
            else:
                gap: float = (start - block_end).total_seconds()
                if gap > _WORK_GAP_SECONDS and start.hour >= 5:
                    blocks.append((block_start, block_end))
                    block_start, block_end = start, end
                else:
                    block_end = max(block_end, end)
        if block_start is not None:
            blocks.append((block_start, block_end))
        return blocks


class DailyWork:
    """日ごとの勤務統計"""

    def __init__(self, events: list[dict]) -> None:
        self._not_afk: list[dict] = [e for e in events if e["data"]["status"] == "not-afk"]

    @property
    def active(self) -> dict[date, float]:
        result: dict[date, float] = {}
        for event in self._not_afk:
            start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(_TIMEZONE)
            wd: date = self._work_date(start)
            result[wd] = result.get(wd, 0) + event["duration"]
        return result

    @property
    def gaps(self) -> dict[date, float]:
        events_by_day: dict[date, list[tuple[datetime, datetime]]] = {}
        for event in self._not_afk:
            if event["duration"] < 5:
                continue
            start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(_TIMEZONE)
            end: datetime = start + timedelta(seconds=event["duration"])
            wd: date = self._work_date(start)
            if wd not in events_by_day:
                events_by_day[wd] = []
            events_by_day[wd].append((start, end))
        return self._calc_max_gaps(events_by_day)

    def _calc_max_gaps(self, events_by_day: dict[date, list[tuple[datetime, datetime]]]) -> dict[date, float]:
        result: dict[date, float] = {}
        for wd, events in events_by_day.items():
            sorted_events: list[tuple[datetime, datetime]] = sorted(events)
            max_gap: float = 0
            max_end: datetime = sorted_events[0][1] if sorted_events else datetime.min
            for i in range(1, len(sorted_events)):
                gap: float = (sorted_events[i][0] - max_end).total_seconds()
                if gap > 0:
                    max_gap = max(max_gap, gap)
                max_end = max(max_end, sorted_events[i][1])
            result[wd] = max_gap
        return result

    def _work_date(self, dt: datetime) -> date:
        return (dt - timedelta(days=1)).date() if 0 <= dt.hour < 5 else dt.date()


class HolidayCalendar:
    """日本の祝日カレンダー（キャッシュ付き）"""

    _API_URL: str = "https://holidays-jp.github.io/api/v1/{year}/date.json"

    def __init__(self) -> None:
        self._cache_dir: Path = Path(__file__).parent / "holiday_cache"
        self._holidays: dict[int, set[date]] = {}

    def is_holiday(self, d: date) -> bool:
        return d.weekday() >= 5 or self._is_national(d)

    def _is_national(self, d: date) -> bool:
        if d.year not in self._holidays:
            self._load_year(d.year)
        return d in self._holidays.get(d.year, set())

    def _load_year(self, year: int) -> None:
        cache_file: Path = self._cache_dir / f"{year}.json"
        if cache_file.exists():
            self._holidays[year] = self._parse_cache(cache_file)
        else:
            self._holidays[year] = self._fetch_and_cache(year, cache_file)

    def _parse_cache(self, cache_file: Path) -> set[date]:
        with open(cache_file, encoding="utf-8") as f:
            return {date.fromisoformat(d) for d in json.load(f).keys()}

    def _fetch_and_cache(self, year: int, cache_file: Path) -> set[date]:
        url: str = self._API_URL.format(year=year)
        try:
            ctx: ssl.SSLContext = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            with urllib.request.urlopen(url, timeout=10, context=ctx) as resp:
                raw: bytes = resp.read()
                holidays: dict[str, str] = json.loads(raw.decode("utf-8"))
            self._cache_dir.mkdir(exist_ok=True)
            with open(cache_file, "w", encoding="utf-8") as f:
                f.write(raw.decode("utf-8") + "\n")
            return {date.fromisoformat(d) for d in holidays.keys()}
        except urllib.error.URLError:
            return set()


class WorkCalendar:
    """勤務カレンダー"""

    def __init__(self, daily: dict[date, tuple[datetime, datetime]]) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily

    @classmethod
    def from_blocks(cls, blocks: list[tuple[datetime, datetime]]) -> "WorkCalendar":
        daily: dict[date, tuple[datetime, datetime]] = {}
        for block_start, block_end in blocks:
            wd: date = cls._work_date(block_start)
            if wd not in daily:
                daily[wd] = (block_start, block_end)
            else:
                s, e = daily[wd]
                daily[wd] = (min(block_start, s), max(block_end, e))
        return cls(daily)

    @classmethod
    def _work_date(cls, dt: datetime) -> date:
        return (dt - timedelta(days=1)).date() if 0 <= dt.hour < 5 else dt.date()

    @property
    def days(self) -> int:
        return len(self._daily)

    @property
    def daily(self) -> dict[date, tuple[datetime, datetime]]:
        return self._daily


class WorkCSV:
    """CSV出力"""

    def __init__(
        self,
        daily: dict[date, tuple[datetime, datetime]],
        active: dict[date, float],
        max_gap: dict[date, float],
        period: MonthPeriod,
    ) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily
        self._active: dict[date, float] = active
        self._max_gap: dict[date, float] = max_gap
        self._period: MonthPeriod = period

    def content(self) -> str:
        lines: list[str] = ["date,weekday,start_time,end_time,duration_hours,afk_hours,max_gap_hours"]
        for d in self._date_range():
            lines.append(self._row(d))
        return "\n".join(lines) + "\n"

    def _date_range(self) -> list[date]:
        today: date = datetime.now(_TIMEZONE).date()
        start_date, end_date = self._period.dates
        if start_date and end_date:
            result: list[date] = []
            current: date = start_date
            end: date = min(end_date, today + timedelta(days=1))
            while current < end:
                result.append(current)
                current += timedelta(days=1)
            return result
        return sorted(self._daily.keys())

    def _row(self, d: date) -> str:
        prefix: str = f'="{d.strftime("%Y-%m-%d")}",{_WEEKDAYS[d.weekday()]}'
        if d not in self._daily:
            return f"{prefix},,,,,"
        start, end = self._daily[d]
        span: float = (end - start).total_seconds() / 3600
        active: float = self._active.get(d, 0) / 3600
        afk: float = span - active
        max_gap: float = self._max_gap.get(d, 0) / 3600
        return f'{prefix},="{self._time(start, d)}",="{self._time(end, d)}",{span:.2f},{afk:.2f},{max_gap:.2f}'

    def _time(self, dt: datetime, base: date) -> str:
        hour: int = dt.hour + ((dt.date() - base).days * 24)
        return f"{hour:02d}:{dt.minute:02d}"


class WorkText:
    """テキスト出力"""

    def __init__(
        self,
        daily: dict[date, tuple[datetime, datetime]],
        active: dict[date, float],
        max_gap: dict[date, float],
        period: MonthPeriod,
        holidays: HolidayCalendar,
        no_colon: bool = False,
    ) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily
        self._active: dict[date, float] = active
        self._max_gap: dict[date, float] = max_gap
        self._period: MonthPeriod = period
        self._holidays: HolidayCalendar = holidays
        self._no_colon: bool = no_colon

    def content(self) -> str:
        today: date = datetime.now(_TIMEZONE).date()
        start_date, end_date = self._period.dates
        if start_date and end_date:
            start, end = start_date, min(end_date, today + timedelta(days=1))
        elif self._daily:
            start = min(self._daily.keys())
            end = max(self._daily.keys()) + timedelta(days=1)
        else:
            return ""
        lines: list[str] = []
        current: date = start
        while current < end:
            lines.append(self._day(current))
            current += timedelta(days=1)
        return "\n".join(lines) + "\n" if lines else ""

    def _day(self, d: date) -> str:
        weekday: str = _WEEKDAYS[d.weekday()]
        has_work: bool = d in self._daily
        is_holiday: bool = has_work and self._holidays.is_holiday(d)
        holiday_mark: str = "*" if is_holiday else ""
        prefix: str = f'{d.strftime("%Y-%m-%d")} {weekday}{holiday_mark}'
        if not has_work:
            return prefix
        return self._format_work_day(d, prefix, is_holiday)

    def _format_work_day(self, d: date, prefix: str, is_holiday: bool) -> str:
        s, e = self._daily[d]
        span: float = (e - s).total_seconds() / 3600
        if round(span, 1) == 0:
            return prefix
        active: float = self._active.get(d, 0) / 3600
        afk: float = span - active
        spacing: str = "  " if is_holiday else "   "
        base: str = f"{prefix}{spacing}{self._time(s, d)} - {self._time(e, d)}   ({span:.1f}h)"
        if afk < 0.05:
            return base
        max_gap: float = self._max_gap.get(d, 0) / 3600
        return f"{base}   -{afk:.1f}h (max:-{max_gap:.1f}h)"

    def _time(self, dt: datetime, base: date) -> str:
        hour: int = dt.hour + ((dt.date() - base).days * 24)
        sep: str = "" if self._no_colon else ":"
        return f"{hour:02d}{sep}{dt.minute:02d}"


class WorkHTMLTemplate:
    """HTML出力テンプレート"""

    @classmethod
    def render(cls, no_colon: bool, init_month: str | None) -> str:
        no_colon_js: str = "true" if no_colon else "false"
        init_month_js: str = f"'{init_month}'" if init_month else "null"
        return cls._html(no_colon_js, init_month_js)

    @classmethod
    def _html(cls, no_colon_js: str, init_month_js: str) -> str:
        return f'''<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Work Hours</title>
{cls._css()}
</head>
<body>
<h2>Work Hours - Active Time Visualization</h2>
{cls._controls()}
<table id="table"></table>
{cls._script(no_colon_js, init_month_js)}
</body>
</html>
'''

    @classmethod
    def _css(cls) -> str:
        return '''<style>
body { font-family: monospace; margin: 20px; background: #fafafa; }
.controls { margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
.controls button { padding: 5px 15px; cursor: pointer; }
.controls input[type="month"] { padding: 5px; width: 100px; font-family: monospace; }
.controls input[type="checkbox"] { width: auto; }
.status { color: #888; margin-left: 10px; }
table { border-collapse: collapse; width: 100%; }
td { padding: 2px 4px; vertical-align: middle; }
td.date { white-space: nowrap; }
td.time { white-space: nowrap; text-align: right; }
td.dur { white-space: nowrap; text-align: right; }
td.afk { white-space: nowrap; text-align: right; color: #888; }
td.timeline-cell { width: 100%; }
.holiday { color: #e57373; }
.timeline { position: relative; height: 18px; background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 3px; }
.event { position: absolute; height: 100%; background: #a5d6a7; cursor: pointer; min-width: 2px; border-radius: 3px; }
.event:hover { background: #81c784; }
.tooltip { display: none; position: absolute; background: #fffde7; border: 1px solid #c5c5c5; padding: 8px; z-index: 100; font-size: 12px; white-space: nowrap; box-shadow: 2px 2px 5px rgba(0,0,0,0.15); border-radius: 4px; }
.tooltip-row { margin: 2px 0; }
.tooltip-label { font-weight: bold; display: inline-block; width: 60px; }
.hour-marks { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }
.hour-mark { position: absolute; top: 0; bottom: 0; border-left: 1px solid #e0e0e0; }
.hour-labels td { font-size: 11px; color: #888; padding: 0 4px 4px 4px; }
.hour-labels td div { display: flex; }
.hour-labels td div span { flex: 1; text-align: left; }
</style>'''

    @classmethod
    def _controls(cls) -> str:
        return '''<div class="controls">
<button id="prev">&lt; 前月</button>
<input type="month" id="month">
<button id="next">次月 &gt;</button>
<label style="margin-left: 15px; cursor: pointer;"><input type="checkbox" id="noColon" style="margin-right: 4px;">コロンなし</label>
<span class="status" id="status"></span>
</div>'''

    @classmethod
    def _script(cls, no_colon_js: str, init_month_js: str) -> str:
        return f'''<script>
const INIT_NO_COLON = {no_colon_js};
const INIT_MONTH = {init_month_js};
let noColon = INIT_NO_COLON;

function formatTime(h, m) {{
    const sep = noColon ? '' : ':';
    return String(h).padStart(2, '0') + sep + String(m).padStart(2, '0');
}}

async function loadMonth(ym) {{
    const status = document.getElementById('status');
    status.textContent = '読み込み中...';
    let data;
    try {{
        const res = await fetch(`/data/${{ym}}`);
        data = await res.json();
    }} catch (e) {{
        status.textContent = 'エラー: データを取得できません';
        return;
    }}
    status.textContent = `勤務: ${{data.rows.filter(r => r.hasWork).length}}日`;
    render(data.rows);
}}

function formatDuration(sec) {{
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return m >= 1 ? `${{m}}m ${{s}}s` : `${{s}}s`;
}}

function render(rows) {{
    const table = document.getElementById('table');
    let html = '<tr class="hour-labels"><td></td><td></td><td></td><td></td><td><div>';
    for (let h = 0; h < 24; h += 4) html += `<span>${{String(h).padStart(2,'0')}}:00</span>`;
    html += '</div></td></tr>';
    for (const row of rows) {{
        const holClass = row.holiday ? ' class="holiday"' : '';
        const holMark = row.holiday ? '*' : '';
        const dateCol = `${{row.date}} ${{row.weekday}}${{holMark}}`;
        let timeCol = '', durCol = '', afkCol = '';
        if (row.hasWork) {{
            timeCol = `${{formatTime(row.startH, row.startM)}} - ${{formatTime(row.endH, row.endM)}}`;
            durCol = `(${{row.span.toFixed(1)}}h)`;
            if (row.afk !== undefined) afkCol = `-${{row.afk.toFixed(1)}}h (max:-${{row.maxGap.toFixed(1)}}h)`;
        }}
        const hourMarks = [4,8,12,16,20].map(h => `<div class="hour-mark" style="left:${{(h/24)*100}}%"></div>`).join('');
        let eventBars = '';
        for (const ev of row.events || []) {{
            const startSec = ev.startH * 3600 + ev.startM * 60 + ev.startS;
            const endSec = ev.endH * 3600 + ev.endM * 60 + ev.endS;
            const left = (startSec / 86400) * 100;
            const width = Math.max(0.1, ((endSec - startSec) / 86400) * 100);
            const startTime = `${{String(ev.startH).padStart(2,'0')}}:${{String(ev.startM).padStart(2,'0')}}:${{String(ev.startS).padStart(2,'0')}}`;
            const endTime = `${{String(ev.endH).padStart(2,'0')}}:${{String(ev.endM).padStart(2,'0')}}:${{String(ev.endS).padStart(2,'0')}}`;
            eventBars += `<div class="event" style="left:${{left.toFixed(2)}}%;width:${{width.toFixed(2)}}%;">
<div class="tooltip">
<div class="tooltip-row"><span class="tooltip-label">Start</span>${{startTime}}</div>
<div class="tooltip-row"><span class="tooltip-label">Stop</span>${{endTime}}</div>
<div class="tooltip-row"><span class="tooltip-label">Duration</span>${{formatDuration(ev.duration)}}</div>
<div class="tooltip-row"><span class="tooltip-label">Data</span>${{JSON.stringify(ev.data)}}</div>
</div></div>`;
        }}
        html += `<tr${{holClass}}><td class="date">${{dateCol}}</td><td class="time">${{timeCol}}</td><td class="dur">${{durCol}}</td><td class="afk">${{afkCol}}</td><td class="timeline-cell"><div class="timeline"><div class="hour-marks">${{hourMarks}}</div>${{eventBars}}</div></td></tr>`;
    }}
    table.innerHTML = html;
    document.querySelectorAll('.event').forEach(el => {{
        const tooltip = el.querySelector('.tooltip');
        el.addEventListener('mouseenter', () => {{
            tooltip.style.display = 'block';
            tooltip.style.top = '22px';
            tooltip.style.left = '0px';
            tooltip.style.right = 'auto';
            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) {{ tooltip.style.left = 'auto'; tooltip.style.right = '0px'; }}
        }});
        el.addEventListener('mouseleave', () => tooltip.style.display = 'none');
    }});
}}

function changeMonth(delta) {{
    const input = document.getElementById('month');
    const [y, m] = input.value.split('-').map(Number);
    const d = new Date(y, m - 1 + delta, 1);
    input.value = `${{d.getFullYear()}}-${{String(d.getMonth() + 1).padStart(2, '0')}}`;
    loadMonth(input.value);
}}

document.getElementById('prev').addEventListener('click', () => changeMonth(-1));
document.getElementById('next').addEventListener('click', () => changeMonth(1));
document.getElementById('month').addEventListener('change', e => loadMonth(e.target.value));
document.getElementById('noColon').addEventListener('change', e => {{
    noColon = e.target.checked;
    loadMonth(document.getElementById('month').value);
}});

const now = new Date();
const initMonth = INIT_MONTH || `${{now.getFullYear()}}-${{String(now.getMonth() + 1).padStart(2, '0')}}`;
document.getElementById('month').value = initMonth;
document.getElementById('noColon').checked = INIT_NO_COLON;
loadMonth(initMonth);
</script>'''


class WorkHTMLRow:
    """HTML用の日別行データ"""

    def __init__(self, d: date, calendar: WorkCalendar, daily_work: DailyWork, holidays: HolidayCalendar) -> None:
        self._date: date = d
        self._calendar: WorkCalendar = calendar
        self._daily_work: DailyWork = daily_work
        self._holidays: HolidayCalendar = holidays
        self._events: list[dict] = []

    def add_event(self, start: datetime, end: datetime, event: dict) -> None:
        self._add_event_segment(start, end, event)

    def _add_event_segment(self, start: datetime, end: datetime, event: dict) -> None:
        current: date = start.date()
        while current <= end.date():
            if current == self._date:
                day_start: datetime = max(start, datetime.combine(current, datetime.min.time()).replace(tzinfo=_TIMEZONE))
                day_end_limit: datetime = datetime.combine(current + timedelta(days=1), datetime.min.time()).replace(tzinfo=_TIMEZONE)
                day_end: datetime = min(end, day_end_limit)
                if day_end > day_start:
                    self._events.append(self._event_dict(day_start, day_end, current, event))
            current += timedelta(days=1)

    def _event_dict(self, start: datetime, end: datetime, current: date, event: dict) -> dict:
        return {
            "startH": start.hour, "startM": start.minute, "startS": start.second,
            "endH": end.hour if end.date() == current else 24,
            "endM": end.minute if end.date() == current else 0,
            "endS": end.second if end.date() == current else 0,
            "duration": (end - start).total_seconds(),
            "data": event["data"],
        }

    def to_dict(self) -> dict:
        d: date = self._date
        has_work: bool = d in self._calendar.daily
        is_holiday: bool = has_work and self._holidays.is_holiday(d)
        row: dict = {"date": d.isoformat(), "weekday": _WEEKDAYS[d.weekday()], "holiday": is_holiday, "hasWork": has_work}
        if has_work:
            self._add_work_fields(row, d)
        row["events"] = self._events
        return row

    def _add_work_fields(self, row: dict, d: date) -> None:
        s, e = self._calendar.daily[d]
        span: float = (e - s).total_seconds() / 3600
        row["startH"], row["startM"] = s.hour + ((s.date() - d).days * 24), s.minute
        row["endH"], row["endM"] = e.hour + ((e.date() - d).days * 24), e.minute
        row["span"] = round(span, 1)
        active_h: float = self._daily_work.active.get(d, 0) / 3600
        afk: float = span - active_h
        if afk >= 0.05:
            row["afk"] = round(afk, 1)
            row["maxGap"] = round(self._daily_work.gaps.get(d, 0) / 3600, 1)


class WorkHTMLResponse:
    """HTML APIレスポンス生成"""

    def __init__(self, period: MonthPeriod) -> None:
        self._period: MonthPeriod = period

    def json(self) -> dict:
        events: AFKEvents = AFKEvents.fetch(*self._period.iso)
        daily_work: DailyWork = DailyWork(events.raw)
        calendar: WorkCalendar = WorkCalendar.from_blocks(events.work_blocks)
        holidays: HolidayCalendar = HolidayCalendar()
        rows: list[WorkHTMLRow] = self._create_rows(calendar, daily_work, holidays)
        self._populate_events(rows, events)
        return {"rows": [r.to_dict() for r in rows]}

    def _create_rows(self, calendar: WorkCalendar, daily_work: DailyWork, holidays: HolidayCalendar) -> list[WorkHTMLRow]:
        rows: list[WorkHTMLRow] = []
        today: date = datetime.now(_TIMEZONE).date()
        start_date, end_date = self._period.dates
        if not (start_date and end_date):
            return []
        current: date = start_date
        end: date = min(end_date, today + timedelta(days=1))
        while current < end:
            rows.append(WorkHTMLRow(current, calendar, daily_work, holidays))
            current += timedelta(days=1)
        return rows

    def _populate_events(self, rows: list[WorkHTMLRow], events: AFKEvents) -> None:
        not_afk: list[dict] = [e for e in events.raw if e["data"]["status"] == "not-afk" and e["duration"] >= 5]
        for ev in not_afk:
            start: datetime = datetime.fromisoformat(ev["timestamp"]).astimezone(_TIMEZONE)
            end: datetime = start + timedelta(seconds=ev["duration"])
            for row in rows:
                row.add_event(start, end, ev)


class WorkHTTPHandler(http.server.SimpleHTTPRequestHandler):
    """HTTPリクエストハンドラ"""

    directory: str = ""

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, directory=self.directory, **kwargs)

    def log_message(self, format: str, *args) -> None:
        pass

    def do_GET(self) -> None:
        if self.path.startswith("/data/"):
            self._handle_data()
        elif self.path.startswith("/api/"):
            self._proxy_api()
        else:
            super().do_GET()

    def _handle_data(self) -> None:
        try:
            month_str: str = self.path.split("/")[-1]
            period: MonthPeriod = MonthPeriod.parse(month_str)
            response: WorkHTMLResponse = WorkHTMLResponse(period)
            body: bytes = json.dumps(response.json(), ensure_ascii=False).encode("utf-8")
            self._send_json(body)
        except Exception as e:
            self.send_error(500, f"Error: {e}")

    def _send_json(self, body: bytes) -> None:
        self.send_response(200)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.send_header("Content-Length", len(body))
        self.end_headers()
        self.wfile.write(body)

    def _proxy_api(self) -> None:
        url: str = f"http://127.0.0.1:5600{self.path}"
        try:
            with urllib.request.urlopen(url, timeout=30) as resp:
                body: bytes = resp.read()
                self._send_json(body)
        except Exception as e:
            self.send_error(502, f"API Error: {e}")


class WorkHTTPServer:
    """HTTPサーバー"""

    def __init__(self, port: int = 8600) -> None:
        self._port: int = port
        self._html_dir: str = tempfile.gettempdir()

    def start(self, no_colon: bool, init_month: str | None, quiet: bool) -> None:
        html_path: Path = Path(self._html_dir) / "aw-work-hours.html"
        with open(html_path, "w", encoding="utf-8") as f:
            f.write(WorkHTMLTemplate.render(no_colon, init_month))
        self._status(f"HTML出力: {html_path}", quiet)
        if not self._is_port_in_use():
            self._start_server(quiet)
        else:
            self._status(f"サーバーは既に起動中 (port {self._port})", quiet)
        self._open_browser(quiet)

    def _is_port_in_use(self) -> bool:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            return s.connect_ex(("localhost", self._port)) == 0

    def _start_server(self, quiet: bool) -> None:
        WorkHTTPHandler.directory = self._html_dir
        def serve() -> None:
            with http.server.HTTPServer(("", self._port), WorkHTTPHandler) as httpd:
                httpd.serve_forever()
        threading.Thread(target=serve, daemon=True).start()
        self._status(f"サーバー起動: http://localhost:{self._port}/", quiet)

    def _open_browser(self, quiet: bool) -> None:
        import time
        url: str = f"http://localhost:{self._port}/aw-work-hours.html"
        self._status(f"ブラウザで開きます: {url}", quiet)
        subprocess.run(["open", url], check=False)
        self._status("Ctrl+C で終了", quiet)
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            self._status("\n終了します", quiet)

    def _status(self, msg: str, quiet: bool) -> None:
        if not quiet:
            print(msg, file=sys.stderr)


class CLIArgs:
    """コマンドライン引数"""

    def __init__(self) -> None:
        self._args: argparse.Namespace = self._parse()

    def _parse(self) -> argparse.Namespace:
        p: argparse.ArgumentParser = argparse.ArgumentParser(
            description="ActivityWatchから勤務時間をCSVにエクスポート",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog=self._epilog(),
        )
        p.add_argument("--month", "-m", default="this", help="対象月: this(今月), last(先月), all(全期間), YYYY-MM")
        p.add_argument("--output", "-o", help="出力ファイル名")
        p.add_argument("--quiet", "-q", action="store_true", help="進捗非表示")
        p.add_argument("--no-colon", action="store_true", help="時刻をHHMMで出力（stdout時のみ）")
        p.add_argument("--html", action="store_true", help="HTML形式でブラウザ表示")
        p.add_argument("--bucket", "-b", help="使用するAFKバケットのPC名（例: Mac, PC-NAME.local）")
        return p.parse_args()

    def _epilog(self) -> str:
        return ("例:\n  aw-work-hours                    今月の勤務時間を出力\n"
                "  aw-work-hours --month=last       先月の勤務時間を出力\n"
                "  aw-work-hours --month=2025-11    2025年11月の勤務時間を出力\n"
                "  aw-work-hours --month=all        全期間の勤務時間を出力\n"
                "  aw-work-hours -o work.csv        ファイルに出力")

    @property
    def month(self) -> str:
        return self._args.month

    @property
    def output(self) -> str | None:
        return self._args.output

    @property
    def quiet(self) -> bool:
        return self._args.quiet

    @property
    def no_colon(self) -> bool:
        return self._args.no_colon

    @property
    def html(self) -> bool:
        return self._args.html

    @property
    def bucket(self) -> str | None:
        return self._args.bucket


class CLIOutput:
    """CLI出力処理"""

    def __init__(self, args: CLIArgs) -> None:
        self._args: CLIArgs = args

    def run(self, calendar: WorkCalendar, daily_work: DailyWork, period: MonthPeriod) -> None:
        holidays: HolidayCalendar = HolidayCalendar()
        if self._args.output:
            self._write_csv(calendar, daily_work, period)
        else:
            self._print_text(calendar, daily_work, period, holidays)

    def _write_csv(self, calendar: WorkCalendar, daily_work: DailyWork, period: MonthPeriod) -> None:
        csv: WorkCSV = WorkCSV(calendar.daily, daily_work.active, daily_work.gaps, period)
        with open(self._args.output, "w", encoding="utf-8-sig") as f:
            f.write(csv.content())
        self._status(f"出力完了: {self._args.output}")

    def _print_text(self, calendar: WorkCalendar, daily_work: DailyWork, period: MonthPeriod, holidays: HolidayCalendar) -> None:
        text: WorkText = WorkText(calendar.daily, daily_work.active, daily_work.gaps, period, holidays, self._args.no_colon)
        print(text.content(), end="")

    def _status(self, msg: str) -> None:
        if not self._args.quiet:
            print(msg, file=sys.stderr)


class CLIMain:
    """メインCLI処理"""

    def __init__(self) -> None:
        self._args: CLIArgs = CLIArgs()

    def run(self) -> None:
        AFKBucket.set_preference(self._args.bucket)
        if self._args.html:
            self._run_html()
        else:
            self._run_text()

    def _run_html(self) -> None:
        init_month: str | None = self._resolve_init_month()
        server: WorkHTTPServer = WorkHTTPServer()
        server.start(self._args.no_colon, init_month, self._args.quiet)

    def _resolve_init_month(self) -> str | None:
        if self._args.month in ("this", "all"):
            return None
        if self._args.month == "last":
            now: datetime = datetime.now(_TIMEZONE)
            y, m = (now.year - 1, 12) if now.month == 1 else (now.year, now.month - 1)
            return f"{y}-{m:02d}"
        return self._args.month

    def _run_text(self) -> None:
        period: MonthPeriod = MonthPeriod.parse(self._args.month)
        labels: dict[str, str] = {"all": "全期間", "this": "今月", "last": "先月"}
        self._status(f"対象期間: {labels.get(self._args.month, self._args.month)}")
        self._status("ActivityWatchからデータを取得中...")
        events: AFKEvents = AFKEvents.fetch(*period.iso)
        self._status(f"取得イベント数: {events.count}")
        daily_work: DailyWork = DailyWork(events.raw)
        calendar: WorkCalendar = WorkCalendar.from_blocks(events.work_blocks)
        self._status(f"勤務日数: {calendar.days}")
        output: CLIOutput = CLIOutput(self._args)
        output.run(calendar, daily_work, period)

    def _status(self, msg: str) -> None:
        if not self._args.quiet:
            print(msg, file=sys.stderr)


if __name__ == "__main__":
    CLIMain().run()
