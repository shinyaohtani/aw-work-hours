#!/usr/bin/env python3
"""
ActivityWatchから日ごとの勤務時間をCSVにエクスポートするコマンド

Usage:
    aw-work-hours                    # 今月の勤務時間を出力
    aw-work-hours --month=last       # 先月の勤務時間を出力
    aw-work-hours --month=2025-11    # 2025年11月の勤務時間を出力
    aw-work-hours --month=all        # 全期間の勤務時間を出力

勤務日の判定ルール:
- 継続している勤務は何時までも同じ日として扱う
- 5:00-8:00の間に新たに開始した勤務は新しい日として扱う
- 24:00をまたいだ場合は26:00のような表記にする
"""

import argparse
import http.server
import json
import socket
import ssl
import subprocess
import sys
import tempfile
import threading
import urllib.error
import urllib.parse
import urllib.request
from datetime import date, datetime, timedelta
from pathlib import Path
from typing import TypedDict
from zoneinfo import ZoneInfo


# MARK: - TYPES — 定数・例外・型定義

_API_BASE: str = "http://127.0.0.1:5600/api/0"
_TIMEZONE: ZoneInfo = ZoneInfo("Asia/Tokyo")
_WEEKDAYS: list[str] = ["月", "火", "水", "木", "金", "土", "日"]


class CLIError(Exception):
    """ユーザー入力や設定のエラー（引数不正・バケット未発見など）"""


class APIConnectionError(Exception):
    """ActivityWatch APIへの接続エラー"""


class AWEvent(TypedDict):
    """ActivityWatch APIから取得するイベント"""

    timestamp: str
    duration: float
    data: dict[str, str]


class HTMLEvent(TypedDict):
    """HTML UI用のイベントデータ"""

    startH: int
    startM: int
    startS: int
    endH: int
    endM: int
    endS: int
    duration: float
    data: dict[str, str]


class Settings:
    """永続化設定（settings.json）"""

    _PATH: Path = Path.home() / ".config" / "aw-work-hours" / "settings.json"

    def __init__(self) -> None:
        self._data: dict[str, object] = self._load()

    def _load(self) -> dict[str, object]:
        try:
            with open(self._PATH, encoding="utf-8") as f:
                return json.load(f)  # type: ignore[no-any-return]
        except (FileNotFoundError, json.JSONDecodeError):
            return {}

    def save(self) -> None:
        self._PATH.parent.mkdir(parents=True, exist_ok=True)
        with open(self._PATH, "w", encoding="utf-8") as f:
            json.dump(self._data, f, ensure_ascii=False, indent=2)
            f.write("\n")

    @property
    def no_colon(self) -> bool:
        return bool(self._data.get("no_colon", False))

    @no_colon.setter
    def no_colon(self, value: bool) -> None:
        self._data["no_colon"] = value

    @property
    def min_event_seconds(self) -> int:
        v: object = self._data.get("min_event_seconds", 150)
        return int(v) if isinstance(v, (int, float, str)) else 150

    @min_event_seconds.setter
    def min_event_seconds(self, value: int) -> None:
        self._data["min_event_seconds"] = value

    @property
    def bucket(self) -> str | None:
        v: object = self._data.get("bucket")
        return str(v) if v is not None else None

    @bucket.setter
    def bucket(self, value: str | None) -> None:
        self._data["bucket"] = value


# MARK: - DOMAIN — ドメインロジック（勤務判定・集計）
#
#  公開API:
#    WorkRule       — 勤務日判定ルール (work_date / adjusted_hour 等)
#    MonthPeriod    — 月の期間解析と日付範囲生成
#    AFKBucket      — AFKバケットの自動選択
#    AFKEvents      — イベント取得とwork block抽出
#    HolidayCalendar — 祝日判定
#    DailyWork      — 日ごとの勤務統計 (active時間・最大gap)
#    WorkCalendar   — 勤務カレンダー (from_period が計算入口)
#  依存: ActivityWatch API, holidays-jp API


# MARK: WorkRule


class WorkRule:
    """勤務日の判定ルール

    - 0:00-4:59の勤務は前日扱い（日境界 = 5:00）
    - 3時間超の離席 かつ 5:00以降に再開 → 別ブロック
    - 24:00超えは26:00のように表記
    """

    _GAP_SECONDS: int = 3 * 60 * 60
    _DAY_BOUNDARY_HOUR: int = 5
    MIN_EVENT_SECONDS: int = 150

    @staticmethod
    def work_date(dt: datetime) -> date:
        """勤務日: 0:00-4:59は前日扱い"""
        return (dt - timedelta(days=1)).date() if 0 <= dt.hour < 5 else dt.date()

    @staticmethod
    def is_block_boundary(gap_seconds: float, start_hour: int) -> bool:
        """3時間超の離席 かつ 5:00以降に再開 → 新ブロック"""
        return (
            gap_seconds > WorkRule._GAP_SECONDS
            and start_hour >= WorkRule._DAY_BOUNDARY_HOUR
        )

    @staticmethod
    def adjusted_hour(dt: datetime, base: date) -> int:
        """日跨ぎ対応の時間表示（25:00等）"""
        return dt.hour + ((dt.date() - base).days * 24)

    @staticmethod
    def span_hours(start: datetime, end: datetime) -> float:
        """時間幅（時間単位）"""
        return (end - start).total_seconds() / 3600


# MARK: MonthPeriod


class MonthPeriod:
    """月の期間"""

    def __init__(self, start: datetime | None, end: datetime | None) -> None:
        self._start: datetime | None = start
        self._end: datetime | None = end

    @classmethod
    def parse(cls, month_str: str) -> "MonthPeriod":
        if month_str == "all":
            return cls(None, None)
        year, month = cls._parse_year_month(month_str)
        start: datetime = datetime(year, month, 1, tzinfo=_TIMEZONE)
        end_year, end_month = (year + 1, 1) if month == 12 else (year, month + 1)
        end: datetime = datetime(end_year, end_month, 1, tzinfo=_TIMEZONE)
        return cls(start, end)

    @classmethod
    def _parse_year_month(cls, month_str: str) -> tuple[int, int]:
        now: datetime = datetime.now(_TIMEZONE)
        if month_str == "this":
            return now.year, now.month
        if month_str == "last":
            return (now.year - 1, 12) if now.month == 1 else (now.year, now.month - 1)
        try:
            year, month = map(int, month_str.split("-"))
            return year, month
        except ValueError:
            raise CLIError(f"エラー: 無効な月指定です: {month_str}")

    @property
    def iso(self) -> tuple[str | None, str | None]:
        return (
            self._start.isoformat() if self._start else None,
            self._end.isoformat() if self._end else None,
        )

    def date_range(self) -> list[date]:
        if not (self._start and self._end):
            return []
        today: date = datetime.now(_TIMEZONE).date()
        result: list[date] = []
        current: date = self._start.date()
        end: date = min(self._end.date(), today + timedelta(days=1))
        while current < end:
            result.append(current)
            current += timedelta(days=1)
        return result


# MARK: AFKBucket


class AFKBucketCandidates:
    """AFKバケットの候補群"""

    def __init__(self, afk_ids: list[str], preference: str | None) -> None:
        self._afk_ids: list[str] = afk_ids
        self._preference: str | None = preference

    @property
    def selected(self) -> str:
        if not self._afk_ids:
            raise CLIError(
                "エラー: AFKバケットが見つかりません\n"
                "aw-watcher-afkが有効か確認してください"
            )
        if self._preference:
            return self._by_preference()
        if len(self._afk_ids) == 1:
            return self._afk_ids[0]
        return self._by_latest()

    def _by_preference(self) -> str:
        pref: str = self._preference or ""
        matched: list[str] = [b for b in self._afk_ids if pref.lower() in b.lower()]
        if not matched:
            lines: list[str] = [
                f"エラー: '{self._preference}' にマッチするバケットが見つかりません",
                "利用可能なバケット:",
            ]
            for bid in self._afk_ids:
                lines.append(f"  {bid.replace('aw-watcher-afk_', '')}")
            raise CLIError("\n".join(lines))
        if len(matched) > 1:
            lines = [
                f"エラー: '{self._preference}' に複数のバケットがマッチしました:",
            ]
            for bid in matched:
                lines.append(f"  {bid.replace('aw-watcher-afk_', '')}")
            raise CLIError("\n".join(lines))
        return matched[0]

    def _by_latest(self) -> str:
        ranked: list[tuple[str, datetime | None, str]] = []
        for bid in self._afk_ids:
            hostname: str = bid.replace("aw-watcher-afk_", "")
            ranked.append((bid, self._last_event(bid), hostname))
        ranked.sort(
            key=lambda x: x[1] or datetime.min.replace(tzinfo=_TIMEZONE), reverse=True
        )
        # 複数バケット検出時の情報表示（候補の詳細はここでしか参照できない）
        print(
            "複数のAFKバケットが見つかりました（PC名ごとに記録が分かれています）:",
            file=sys.stderr,
        )
        for i, (_, last, hostname) in enumerate(ranked):
            last_str: str = last.strftime("%Y-%m-%d %H:%M") if last else "データなし"
            marker: str = " ← 使用" if i == 0 else ""
            print(f"  {hostname}: 最終記録 {last_str}{marker}", file=sys.stderr)
        print("最新のデータを持つバケットを自動選択しました。", file=sys.stderr)
        print("特定のバケットを使う場合: --bucket=PC名", file=sys.stderr)
        return ranked[0][0]

    def _last_event(self, bucket_id: str) -> datetime | None:
        url: str = f"{_API_BASE}/buckets/{bucket_id}/events?limit=1"
        try:
            with urllib.request.urlopen(url, timeout=5) as resp:
                events: list[AWEvent] = json.loads(resp.read().decode())
                if events:
                    return datetime.fromisoformat(events[0]["timestamp"]).astimezone(
                        _TIMEZONE
                    )
        except (urllib.error.URLError, KeyError, IndexError):
            pass
        return None


class AFKBucket:
    """ActivityWatchのAFKバケット"""

    _cached_id: str | None = None
    _preference: str | None = None

    @classmethod
    def set_preference(cls, hostname: str | None) -> None:
        cls._preference = hostname

    @classmethod
    def id(cls) -> str:
        if cls._cached_id:
            return cls._cached_id
        afk_ids: list[str] = cls._fetch_ids()
        cls._cached_id = cls._resolve(afk_ids)
        return cls._cached_id

    @classmethod
    def _fetch_ids(cls) -> list[str]:
        url: str = f"{_API_BASE}/buckets"
        try:
            with urllib.request.urlopen(url, timeout=10) as resp:
                buckets: dict = json.loads(resp.read().decode())  # type: ignore[type-arg]
        except urllib.error.URLError as e:
            raise APIConnectionError(
                "エラー: ActivityWatch APIに接続できません\n"
                "ActivityWatchが起動しているか確認してください\n"
                f"詳細: {e}"
            ) from e
        return [b for b in buckets if b.startswith("aw-watcher-afk_")]

    @classmethod
    def _resolve(cls, afk_ids: list[str]) -> str:
        candidates: AFKBucketCandidates = AFKBucketCandidates(afk_ids, cls._preference)
        return candidates.selected


# MARK: AFKEvents


class AFKEvents:
    """ActivityWatchのAFKイベント"""

    def __init__(self, events: list[AWEvent]) -> None:
        self._events: list[AWEvent] = events

    @classmethod
    def fetch(cls, start: str | None, end: str | None) -> "AFKEvents":
        url: str = f"{_API_BASE}/buckets/{AFKBucket.id()}/events"
        params: dict[str, str] = {"limit": "-1"}
        if start:
            params["start"] = start
        if end:
            params["end"] = end
        url += "?" + urllib.parse.urlencode(params)
        try:
            with urllib.request.urlopen(url, timeout=30) as resp:
                return cls(json.loads(resp.read().decode()))
        except urllib.error.URLError as e:
            raise APIConnectionError(
                "エラー: ActivityWatch APIに接続できません\n"
                "ActivityWatchが起動しているか確認してください\n"
                f"詳細: {e}"
            ) from e

    @property
    def raw(self) -> list[AWEvent]:
        return self._events

    @property
    def work_blocks(self) -> list[tuple[datetime, datetime]]:
        not_afk: list[AWEvent] = sorted(
            [
                e
                for e in self._events
                if e["data"]["status"] == "not-afk"
                and e["duration"] >= WorkRule.MIN_EVENT_SECONDS
            ],
            key=lambda e: e["timestamp"],
        )
        return self._extract_blocks(not_afk) if not_afk else []

    def _extract_blocks(self, events: list[AWEvent]) -> list[tuple[datetime, datetime]]:
        blocks: list[tuple[datetime, datetime]] = []
        block_start: datetime | None = None
        block_end: datetime = datetime.min.replace(tzinfo=_TIMEZONE)
        for event in events:
            start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(
                _TIMEZONE
            )
            end: datetime = start + timedelta(seconds=event["duration"])
            if block_start is None:
                block_start, block_end = start, end
            else:
                gap: float = (start - block_end).total_seconds()
                if WorkRule.is_block_boundary(gap, start.hour):
                    blocks.append((block_start, block_end))
                    block_start, block_end = start, end
                else:
                    block_end = max(block_end, end)
        if block_start is not None:
            blocks.append((block_start, block_end))
        return blocks


# MARK: HolidayCalendar


class HolidayCalendar:
    """日本の祝日カレンダー（キャッシュ付き）"""

    _API_URL: str = "https://holidays-jp.github.io/api/v1/{year}/date.json"

    def __init__(self) -> None:
        self._cache_dir: Path = Path(__file__).parent / "holiday_cache"
        self._holidays: dict[int, set[date]] = {}

    def is_holiday(self, d: date) -> bool:
        return d.weekday() >= 5 or self._is_national(d)

    def _is_national(self, d: date) -> bool:
        if d.year not in self._holidays:
            self._load_year(d.year)
        return d in self._holidays.get(d.year, set())

    def _load_year(self, year: int) -> None:
        cache_file: Path = self._cache_dir / f"{year}.json"
        if cache_file.exists():
            self._holidays[year] = self._parse_cache(cache_file)
        else:
            self._holidays[year] = self._fetch_and_cache(year, cache_file)

    def _parse_cache(self, cache_file: Path) -> set[date]:
        with open(cache_file, encoding="utf-8") as f:
            return {date.fromisoformat(d) for d in json.load(f).keys()}

    def _fetch_and_cache(self, year: int, cache_file: Path) -> set[date]:
        url: str = self._API_URL.format(year=year)
        try:
            ctx: ssl.SSLContext = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            with urllib.request.urlopen(url, timeout=10, context=ctx) as resp:
                raw: bytes = resp.read()
                holidays: dict[str, str] = json.loads(raw.decode("utf-8"))
            self._cache_dir.mkdir(exist_ok=True)
            with open(cache_file, "w", encoding="utf-8") as f:
                f.write(raw.decode("utf-8") + "\n")
            return {date.fromisoformat(d) for d in holidays.keys()}
        except urllib.error.URLError:
            # 祝日API接続失敗は致命的でないため空を返す（表示上の差異のみ）
            return set()


# MARK: DailyWork


class DailyWork:
    """日ごとの勤務統計"""

    def __init__(self, events: list[AWEvent]) -> None:
        self._not_afk: list[AWEvent] = [
            e for e in events if e["data"]["status"] == "not-afk"
        ]

    @property
    def active(self) -> dict[date, float]:
        result: dict[date, float] = {}
        for event in self._not_afk:
            start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(
                _TIMEZONE
            )
            wd: date = WorkRule.work_date(start)
            result[wd] = result.get(wd, 0) + event["duration"]
        return result

    @property
    def gaps(self) -> dict[date, float]:
        events_by_day: dict[date, list[tuple[datetime, datetime]]] = {}
        for event in self._not_afk:
            if event["duration"] < WorkRule.MIN_EVENT_SECONDS:
                continue
            start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(
                _TIMEZONE
            )
            end: datetime = start + timedelta(seconds=event["duration"])
            wd: date = WorkRule.work_date(start)
            if wd not in events_by_day:
                events_by_day[wd] = []
            events_by_day[wd].append((start, end))
        return self._calc_max_gaps(events_by_day)

    def _calc_max_gaps(
        self, events_by_day: dict[date, list[tuple[datetime, datetime]]]
    ) -> dict[date, float]:
        result: dict[date, float] = {}
        for wd, events in events_by_day.items():
            sorted_events: list[tuple[datetime, datetime]] = sorted(events)
            max_gap: float = 0
            max_end: datetime = sorted_events[0][1] if sorted_events else datetime.min
            for i in range(1, len(sorted_events)):
                gap: float = (sorted_events[i][0] - max_end).total_seconds()
                if gap > 0:
                    max_gap = max(max_gap, gap)
                max_end = max(max_end, sorted_events[i][1])
            result[wd] = max_gap
        return result


# MARK: WorkCalendar


class WorkCalendar:
    """勤務カレンダー"""

    def __init__(self, daily: dict[date, tuple[datetime, datetime]]) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily

    @classmethod
    def from_blocks(cls, blocks: list[tuple[datetime, datetime]]) -> "WorkCalendar":
        daily: dict[date, tuple[datetime, datetime]] = {}
        for block_start, block_end in blocks:
            wd: date = WorkRule.work_date(block_start)
            if wd not in daily:
                daily[wd] = (block_start, block_end)
            else:
                s, e = daily[wd]
                daily[wd] = (min(block_start, s), max(block_end, e))
        return cls(daily)

    @classmethod
    def from_period(
        cls, period: MonthPeriod
    ) -> tuple["WorkCalendar", DailyWork, AFKEvents]:
        """ドメイン計算の入口: 期間→カレンダー・勤務統計・イベント"""
        events: AFKEvents = AFKEvents.fetch(*period.iso)
        daily_work: DailyWork = DailyWork(events.raw)
        calendar: "WorkCalendar" = cls.from_blocks(events.work_blocks)
        return calendar, daily_work, events

    @property
    def days(self) -> int:
        return len(self._daily)

    @property
    def daily(self) -> dict[date, tuple[datetime, datetime]]:
        return self._daily


# MARK: - OUTPUT — テキスト・CSV出力
#
#  公開API: WorkCSV.content(), WorkText.content()
#  依存: Domain層 (MonthPeriod, HolidayCalendar, WorkRule)


# MARK: WorkCSV


class WorkCSV:
    """CSV出力"""

    def __init__(
        self,
        daily: dict[date, tuple[datetime, datetime]],
        active: dict[date, float],
        max_gap: dict[date, float],
        period: MonthPeriod,
    ) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily
        self._active: dict[date, float] = active
        self._max_gap: dict[date, float] = max_gap
        self._period: MonthPeriod = period

    def content(self) -> str:
        lines: list[str] = [
            "date,weekday,start_time,end_time,duration_hours,afk_hours,max_gap_hours"
        ]
        for d in self._date_range():
            lines.append(self._row(d))
        return "\n".join(lines) + "\n"

    def _date_range(self) -> list[date]:
        dates: list[date] = self._period.date_range()
        return dates if dates else sorted(self._daily.keys())

    def _row(self, d: date) -> str:
        prefix: str = f'="{d.strftime("%Y-%m-%d")}",{_WEEKDAYS[d.weekday()]}'
        if d not in self._daily:
            return f"{prefix},,,,,"
        start, end = self._daily[d]
        span: float = WorkRule.span_hours(start, end)
        active: float = self._active.get(d, 0) / 3600
        afk: float = span - active
        max_gap: float = self._max_gap.get(d, 0) / 3600
        return f'{prefix},="{self._time(start, d)}",="{self._time(end, d)}",{span:.2f},{afk:.2f},{max_gap:.2f}'

    def _time(self, dt: datetime, base: date) -> str:
        hour: int = WorkRule.adjusted_hour(dt, base)
        return f"{hour:02d}:{dt.minute:02d}"


# MARK: WorkText


class WorkText:
    """テキスト出力"""

    def __init__(
        self,
        daily: dict[date, tuple[datetime, datetime]],
        active: dict[date, float],
        max_gap: dict[date, float],
        period: MonthPeriod,
        holidays: HolidayCalendar,
        no_colon: bool = False,
    ) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily
        self._active: dict[date, float] = active
        self._max_gap: dict[date, float] = max_gap
        self._period: MonthPeriod = period
        self._holidays: HolidayCalendar = holidays
        self._no_colon: bool = no_colon

    def content(self) -> str:
        dates: list[date] = self._period.date_range()
        if not dates and self._daily:
            start: date = min(self._daily.keys())
            end: date = max(self._daily.keys()) + timedelta(days=1)
            current: date = start
            while current < end:
                dates.append(current)
                current += timedelta(days=1)
        lines: list[str] = [self._day(d) for d in dates]
        return "\n".join(lines) + "\n" if lines else ""

    def _day(self, d: date) -> str:
        weekday: str = _WEEKDAYS[d.weekday()]
        has_work: bool = d in self._daily
        is_holiday: bool = has_work and self._holidays.is_holiday(d)
        holiday_mark: str = "*" if is_holiday else ""
        prefix: str = f'{d.strftime("%Y-%m-%d")} {weekday}{holiday_mark}'
        if not has_work:
            return prefix
        return self._format_work_day(d, prefix, is_holiday)

    def _format_work_day(self, d: date, prefix: str, is_holiday: bool) -> str:
        s, e = self._daily[d]
        span: float = WorkRule.span_hours(s, e)
        if round(span, 1) == 0:
            return prefix
        active: float = self._active.get(d, 0) / 3600
        afk: float = span - active
        spacing: str = "  " if is_holiday else "   "
        base: str = (
            f"{prefix}{spacing}{self._time(s, d)} - {self._time(e, d)}   ({span:.1f}h)"
        )
        if afk < 0.05:
            return base
        max_gap: float = self._max_gap.get(d, 0) / 3600
        return f"{base}   -{afk:.1f}h (max:-{max_gap:.1f}h)"

    def _time(self, dt: datetime, base: date) -> str:
        hour: int = WorkRule.adjusted_hour(dt, base)
        sep: str = "" if self._no_colon else ":"
        return f"{hour:02d}{sep}{dt.minute:02d}"


# MARK: - WEB — HTML UI・HTTPサーバー
#
#  公開API: WorkHTTPServer.start()
#  依存: Domain層
#  ※ テンプレート文字列 (CSS/JS) はセクション末尾の WorkHTMLTemplate に集約


# MARK: WorkHTMLRow


class WorkHTMLRow:
    """HTML用の日別行データ"""

    def __init__(
        self,
        d: date,
        calendar: WorkCalendar,
        daily_work: DailyWork,
        holidays: HolidayCalendar,
    ) -> None:
        self._date: date = d
        self._calendar: WorkCalendar = calendar
        self._daily_work: DailyWork = daily_work
        self._holidays: HolidayCalendar = holidays
        self._events: list[HTMLEvent] = []

    def add_event(self, start: datetime, end: datetime, event: AWEvent) -> None:
        current: date = start.date()
        while current <= end.date():
            if current == self._date:
                day_start: datetime = max(
                    start,
                    datetime.combine(current, datetime.min.time()).replace(
                        tzinfo=_TIMEZONE
                    ),
                )
                day_end_limit: datetime = datetime.combine(
                    current + timedelta(days=1), datetime.min.time()
                ).replace(tzinfo=_TIMEZONE)
                day_end: datetime = min(end, day_end_limit)
                if day_end > day_start:
                    self._events.append(
                        self._event_dict(day_start, day_end, current, event)
                    )
            current += timedelta(days=1)

    def _event_dict(
        self, start: datetime, end: datetime, current: date, event: AWEvent
    ) -> HTMLEvent:
        return {
            "startH": start.hour,
            "startM": start.minute,
            "startS": start.second,
            "endH": end.hour if end.date() == current else 24,
            "endM": end.minute if end.date() == current else 0,
            "endS": end.second if end.date() == current else 0,
            "duration": (end - start).total_seconds(),
            "data": event["data"],
        }

    def to_dict(self) -> dict:
        d: date = self._date
        has_work: bool = d in self._calendar.daily
        is_holiday: bool = has_work and self._holidays.is_holiday(d)
        row: dict = {
            "date": d.isoformat(),
            "weekday": _WEEKDAYS[d.weekday()],
            "holiday": is_holiday,
            "hasWork": has_work,
        }
        if has_work:
            self._add_work_fields(row, d)
        row["events"] = self._events
        return row

    def _add_work_fields(self, row: dict, d: date) -> None:
        s, e = self._calendar.daily[d]
        span: float = WorkRule.span_hours(s, e)
        row["startH"] = WorkRule.adjusted_hour(s, d)
        row["startM"] = s.minute
        row["endH"] = WorkRule.adjusted_hour(e, d)
        row["endM"] = e.minute
        row["span"] = round(span, 1)
        active_h: float = self._daily_work.active.get(d, 0) / 3600
        afk: float = span - active_h
        if afk >= 0.05:
            row["afk"] = round(afk, 1)
            row["maxGap"] = round(self._daily_work.gaps.get(d, 0) / 3600, 1)


# MARK: WorkHTMLResponse


class WorkHTMLResponse:
    """HTML APIレスポンス生成"""

    def __init__(self, period: MonthPeriod) -> None:
        self._period: MonthPeriod = period

    def json(self) -> dict:
        calendar, daily_work, events = WorkCalendar.from_period(self._period)
        holidays: HolidayCalendar = HolidayCalendar()
        rows: list[WorkHTMLRow] = self._create_rows(calendar, daily_work, holidays)
        self._populate_events(rows, events)
        return {"rows": [r.to_dict() for r in rows]}

    def _create_rows(
        self, calendar: WorkCalendar, daily_work: DailyWork, holidays: HolidayCalendar
    ) -> list[WorkHTMLRow]:
        return [
            WorkHTMLRow(d, calendar, daily_work, holidays)
            for d in self._period.date_range()
        ]

    def _populate_events(self, rows: list[WorkHTMLRow], events: AFKEvents) -> None:
        not_afk: list[AWEvent] = [
            e
            for e in events.raw
            if e["data"]["status"] == "not-afk"
            and e["duration"] >= WorkRule.MIN_EVENT_SECONDS
        ]
        for ev in not_afk:
            start: datetime = datetime.fromisoformat(ev["timestamp"]).astimezone(
                _TIMEZONE
            )
            end: datetime = start + timedelta(seconds=ev["duration"])
            for row in rows:
                row.add_event(start, end, ev)


# MARK: WorkHTTPHandler


class WorkHTTPHandler(http.server.SimpleHTTPRequestHandler):
    """HTTPリクエストハンドラ"""

    directory: str = ""

    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]
        super().__init__(*args, directory=self.directory, **kwargs)

    def log_message(self, format: str, *args) -> None:
        pass

    def do_GET(self) -> None:
        if self.path.startswith("/data/"):
            self._handle_data()
        elif self.path == "/settings":
            self._handle_get_settings()
        elif self.path == "/settings/buckets":
            self._handle_get_buckets()
        elif self.path.startswith("/api/"):
            self._proxy_api()
        else:
            super().do_GET()

    def do_POST(self) -> None:
        if self.path == "/settings":
            self._handle_post_settings()
        else:
            self.send_error(404)

    def _handle_get_settings(self) -> None:
        try:
            settings: Settings = Settings()
            body: bytes = json.dumps(
                {
                    "no_colon": settings.no_colon,
                    "min_event_seconds": settings.min_event_seconds,
                    "bucket": settings.bucket,
                },
                ensure_ascii=False,
            ).encode("utf-8")
            self._send_json(body)
        except Exception as e:
            self.send_error(500, f"Error: {e}")

    def _handle_get_buckets(self) -> None:
        try:
            afk_ids: list[str] = AFKBucket._fetch_ids()
            hostnames: list[str] = [
                bid.replace("aw-watcher-afk_", "") for bid in afk_ids
            ]
            body: bytes = json.dumps(hostnames, ensure_ascii=False).encode("utf-8")
            self._send_json(body)
        except Exception as e:
            self.send_error(500, f"Error: {e}")

    def _handle_post_settings(self) -> None:
        try:
            length: int = int(self.headers.get("Content-Length", 0))
            raw: bytes = self.rfile.read(length)
            data: dict[str, object] = json.loads(raw.decode("utf-8"))
            settings: Settings = Settings()
            if "no_colon" in data:
                settings.no_colon = bool(data["no_colon"])
            if "min_event_seconds" in data:
                settings.min_event_seconds = int(data["min_event_seconds"])  # type: ignore[arg-type]
            if "bucket" in data:
                settings.bucket = str(data["bucket"]) if data["bucket"] else None
            settings.save()
            WorkRule.MIN_EVENT_SECONDS = settings.min_event_seconds
            AFKBucket._cached_id = None
            AFKBucket.set_preference(settings.bucket)
            body: bytes = json.dumps(
                {
                    "no_colon": settings.no_colon,
                    "min_event_seconds": settings.min_event_seconds,
                    "bucket": settings.bucket,
                },
                ensure_ascii=False,
            ).encode("utf-8")
            self._send_json(body)
        except Exception as e:
            self.send_error(500, f"Error: {e}")

    def _handle_data(self) -> None:
        try:
            month_str: str = self.path.split("/")[-1]
            period: MonthPeriod = MonthPeriod.parse(month_str)
            response: WorkHTMLResponse = WorkHTMLResponse(period)
            body: bytes = json.dumps(response.json(), ensure_ascii=False).encode(
                "utf-8"
            )
            self._send_json(body)
        except Exception as e:
            self.send_error(500, f"Error: {e}")

    def _send_json(self, body: bytes) -> None:
        self.send_response(200)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def _proxy_api(self) -> None:
        url: str = f"http://127.0.0.1:5600{self.path}"
        try:
            with urllib.request.urlopen(url, timeout=30) as resp:
                body: bytes = resp.read()
                self._send_json(body)
        except Exception as e:
            self.send_error(502, f"API Error: {e}")


# MARK: WorkHTTPServer


class WorkHTTPServer:
    """HTTPサーバー"""

    def __init__(self, port: int = 8600) -> None:
        self._port: int = port
        self._html_dir: str = tempfile.gettempdir()

    def start(self, html: str, quiet: bool) -> None:
        html_path: Path = Path(self._html_dir) / "aw-work-hours.html"
        with open(html_path, "w", encoding="utf-8") as f:
            f.write(html)
        self._status(f"HTML出力: {html_path}", quiet)
        if not self._is_port_in_use():
            self._start_server(quiet)
        else:
            self._status(f"サーバーは既に起動中 (port {self._port})", quiet)
        self._open_browser(quiet)

    def _is_port_in_use(self) -> bool:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            return s.connect_ex(("localhost", self._port)) == 0

    def _start_server(self, quiet: bool) -> None:
        WorkHTTPHandler.directory = self._html_dir

        def serve() -> None:
            with http.server.HTTPServer(("", self._port), WorkHTTPHandler) as httpd:
                httpd.serve_forever()

        threading.Thread(target=serve, daemon=True).start()
        self._status(f"サーバー起動: http://localhost:{self._port}/", quiet)

    def _open_browser(self, quiet: bool) -> None:
        import time

        url: str = f"http://localhost:{self._port}/aw-work-hours.html"
        self._status(f"ブラウザで開きます: {url}", quiet)
        subprocess.run(["open", url], check=False)
        self._status("Ctrl+C で終了", quiet)
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            self._status("\n終了します", quiet)

    def _status(self, msg: str, quiet: bool) -> None:
        if not quiet:
            print(msg, file=sys.stderr)


# MARK: WorkHTMLTemplate


class WorkHTMLTemplate:
    """HTML出力テンプレート（CSS/JS含む）"""

    @classmethod
    def render(cls, settings: Settings, init_month: str | None) -> str:
        no_colon_js: str = "true" if settings.no_colon else "false"
        min_event_js: str = str(settings.min_event_seconds)
        init_month_js: str = f"'{init_month}'" if init_month else "null"
        return cls._html(no_colon_js, min_event_js, init_month_js)

    @classmethod
    def _html(cls, no_colon_js: str, min_event_js: str, init_month_js: str) -> str:
        css: str = cls._css()
        controls: str = cls._controls()
        script: str = cls._script(no_colon_js, min_event_js, init_month_js)
        page: str = (
            f'<!DOCTYPE html>\n<html lang="ja">\n<head>\n'
            f'<meta charset="UTF-8">\n'
            f'<meta name="viewport" content="width=device-width, initial-scale=1">\n'
            f"<title>Work Hours</title>\n"
            f"{css}\n</head>\n<body>\n"
            f'<div class="page">\n'
            f"<h2>Work Hours</h2>\n"
            f'{controls}\n<table id="table"></table>\n'
            f"</div>\n"
            f"{script}\n</body>\n</html>\n"
        )
        return page

    # MARK: Template Strings

    _CSS: str = "\n".join(
        [
            "<style>",
            "*, *::before, *::after { box-sizing: border-box; }",
            "body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',"
            " Roboto, Helvetica, Arial, sans-serif; margin: 0; background: #f8f9fa;"
            " color: #1a1a2e; }",
            ".page { max-width: 1200px; margin: 0 auto; padding: 24px 32px; }",
            "h2 { font-size: 20px; font-weight: 600; margin: 0 0 20px 0;"
            " color: #1a1a2e; letter-spacing: -0.3px; }",
            # controls
            ".controls { margin-bottom: 20px; display: flex;"
            " align-items: center; gap: 8px; flex-wrap: wrap; }",
            ".controls button { padding: 7px 14px; cursor: pointer;"
            " border: 1px solid #d1d5db; border-radius: 6px; background: #fff;"
            " font-size: 13px; color: #374151; transition: all 0.15s; }",
            ".controls button:hover { background: #f3f4f6; border-color: #9ca3af; }",
            ".controls button:active { background: #e5e7eb; }",
            '.controls input[type="month"] { padding: 7px 10px; width: 120px;'
            " font-family: inherit; font-size: 13px; border: 1px solid #d1d5db;"
            " border-radius: 6px; background: #fff; color: #374151; outline: none; }",
            '.controls input[type="month"]:focus { border-color: #6366f1;'
            " box-shadow: 0 0 0 3px rgba(99,102,241,0.12); }",
            ".controls label { font-size: 13px; cursor: pointer;"
            " display: flex; align-items: center; gap: 5px;"
            " color: #4b5563; user-select: none; margin-left: 8px; }",
            ".settings-btn { border: none !important; background: none !important;"
            " font-size: 20px !important; padding: 4px 6px !important;"
            " color: #6b7280; transition: color 0.15s; margin-left: 4px; }",
            ".settings-btn:hover { color: #374151; background: none !important; }",
            ".status { color: #9ca3af; margin-left: auto;"
            " font-size: 13px; white-space: nowrap; }",
            # table (data rows keep monospace for alignment)
            "table { border-collapse: collapse; width: 100%; }",
            "td { padding: 3px 6px; vertical-align: middle;"
            " font-family: 'SF Mono', 'Cascadia Code', 'Fira Code',"
            " Menlo, monospace; font-size: 13px; }",
            "td.date { white-space: nowrap; }",
            "td.time { white-space: nowrap; text-align: right; }",
            "td.dur { white-space: nowrap; text-align: right; }",
            "td.afk { white-space: nowrap; text-align: right; color: #9ca3af; }",
            "td.timeline-cell { width: 100%; }",
            ".holiday { color: #e57373; }",
            # timeline / event / tooltip — unchanged
            ".timeline { position: relative; height: 18px; background: #f5f5f5;"
            " border: 1px solid #e0e0e0; border-radius: 3px; }",
            ".event { position: absolute; height: 100%; background: #a5d6a7;"
            " cursor: pointer; min-width: 2px; border-radius: 3px; }",
            ".event:hover { background: #81c784; }",
            ".tooltip { display: none; position: absolute; background: #fffde7;"
            " border: 1px solid #c5c5c5; padding: 8px; z-index: 100; font-size: 12px;"
            " white-space: nowrap; box-shadow: 2px 2px 5px rgba(0,0,0,0.15);"
            " border-radius: 4px; }",
            ".tooltip-row { margin: 2px 0; }",
            ".tooltip-label { font-weight: bold; display: inline-block; width: 60px; }",
            ".hour-marks { position: absolute; top: 0; left: 0; right: 0;"
            " bottom: 0; pointer-events: none; }",
            ".hour-mark { position: absolute; top: 0; bottom: 0;"
            " border-left: 1px solid #e0e0e0; }",
            ".hour-labels td { font-size: 11px; color: #888; padding: 0 4px 4px 4px; }",
            ".hour-labels td div { display: flex; }",
            ".hour-labels td div span { flex: 1; text-align: left; }",
            # settings dialog
            ".settings-overlay { display: none; position: fixed; top: 0; left: 0;"
            " width: 100%; height: 100%; background: rgba(0,0,0,0.3);"
            " z-index: 200; backdrop-filter: blur(2px); }",
            ".settings-dialog { position: fixed; top: 50%; left: 50%;"
            " transform: translate(-50%, -50%); background: #fff;"
            " border-radius: 12px; padding: 28px 32px; z-index: 201;"
            " box-shadow: 0 8px 32px rgba(0,0,0,0.12);"
            " min-width: 340px; max-width: 400px; }",
            ".settings-dialog h3 { margin: 0 0 20px 0; font-size: 16px;"
            " font-weight: 600; color: #1a1a2e; }",
            ".settings-dialog .field { margin-bottom: 16px; }",
            ".settings-dialog .field-label { display: block; font-size: 12px;"
            " font-weight: 500; color: #6b7280; margin-bottom: 6px;"
            " text-transform: uppercase; letter-spacing: 0.4px; }",
            ".settings-dialog .field-check { display: flex; align-items: center;"
            " gap: 8px; font-size: 14px; color: #374151; cursor: pointer; }",
            ".settings-dialog select,"
            " .settings-dialog input[type=number]"
            " { padding: 8px 12px; font-family: inherit; font-size: 14px;"
            " border: 1px solid #d1d5db; border-radius: 8px; width: 100%;"
            " background: #fff; color: #374151; outline: none;"
            " transition: border-color 0.15s, box-shadow 0.15s; }",
            ".settings-dialog select:focus,"
            " .settings-dialog input[type=number]:focus"
            " { border-color: #6366f1;"
            " box-shadow: 0 0 0 3px rgba(99,102,241,0.12); }",
            ".settings-dialog .btn-row { margin-top: 24px; display: flex;"
            " justify-content: flex-end; gap: 8px; }",
            ".settings-dialog .btn-row button { padding: 8px 20px; font-size: 14px;"
            " border-radius: 8px; cursor: pointer; font-weight: 500;"
            " transition: all 0.15s; }",
            ".settings-dialog .btn-cancel { border: 1px solid #d1d5db;"
            " background: #fff; color: #374151; }",
            ".settings-dialog .btn-cancel:hover { background: #f3f4f6; }",
            ".settings-dialog .btn-save { border: 1px solid #4f46e5;"
            " background: #4f46e5; color: #fff; }",
            ".settings-dialog .btn-save:hover { background: #4338ca; }",
            "</style>",
        ]
    )

    @classmethod
    def _css(cls) -> str:
        return cls._CSS

    _CONTROLS: str = "\n".join(
        [
            '<div class="controls">',
            '<button id="prev">&#8249; 前月</button>',
            '<input type="month" id="month">',
            '<button id="next">次月 &#8250;</button>',
            "<label>" '<input type="checkbox" id="noColon">' "コロンなし</label>",
            '<button id="settings-btn" class="settings-btn">&#9881;</button>',
            '<span class="status" id="status"></span>',
            "</div>",
        ]
    )

    @classmethod
    def _controls(cls) -> str:
        return cls._CONTROLS

    _SCRIPT_TEMPLATE: str = """<script>
const INIT_NO_COLON = __NO_COLON_JS__;
const INIT_MIN_EVENT = __INIT_MIN_EVENT_JS__;
const INIT_MONTH = __INIT_MONTH_JS__;
let noColon = INIT_NO_COLON;

function formatTime(h, m) {
    const sep = noColon ? '' : ':';
    return String(h).padStart(2, '0') + sep + String(m).padStart(2, '0');
}

async function loadMonth(ym) {
    const status = document.getElementById('status');
    status.textContent = '読み込み中...';
    let data;
    try {
        const res = await fetch(`/data/${ym}`);
        data = await res.json();
    } catch (e) {
        status.textContent = 'エラー: データを取得できません';
        return;
    }
    status.textContent = `勤務: ${data.rows.filter(r => r.hasWork).length}日`;
    render(data.rows);
}

function formatDuration(sec) {
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return m >= 1 ? `${m}m ${s}s` : `${s}s`;
}

function render(rows) {
    const table = document.getElementById('table');
    let html = '<tr class="hour-labels"><td></td><td></td><td></td><td></td><td><div>';
    for (let h = 0; h < 24; h += 4) html += `<span>${String(h).padStart(2,'0')}:00</span>`;
    html += '</div></td></tr>';
    for (const row of rows) {
        const holClass = row.holiday ? ' class="holiday"' : '';
        const holMark = row.holiday ? '*' : '';
        const dateCol = `${row.date} ${row.weekday}${holMark}`;
        let timeCol = '', durCol = '', afkCol = '';
        if (row.hasWork) {
            timeCol = `${formatTime(row.startH, row.startM)} - ${formatTime(row.endH, row.endM)}`;
            durCol = `(${row.span.toFixed(1)}h)`;
            if (row.afk !== undefined) afkCol = `-${row.afk.toFixed(1)}h (max:-${row.maxGap.toFixed(1)}h)`;
        }
        const hourMarks = [4,8,12,16,20].map(h => `<div class="hour-mark" style="left:${(h/24)*100}%"></div>`).join('');
        let eventBars = '';
        for (const ev of row.events || []) {
            const startSec = ev.startH * 3600 + ev.startM * 60 + ev.startS;
            const endSec = ev.endH * 3600 + ev.endM * 60 + ev.endS;
            const left = (startSec / 86400) * 100;
            const width = Math.max(0.1, ((endSec - startSec) / 86400) * 100);
            const startTime = `${String(ev.startH).padStart(2,'0')}:${String(ev.startM).padStart(2,'0')}:${String(ev.startS).padStart(2,'0')}`;
            const endTime = `${String(ev.endH).padStart(2,'0')}:${String(ev.endM).padStart(2,'0')}:${String(ev.endS).padStart(2,'0')}`;
            eventBars += `<div class="event" style="left:${left.toFixed(2)}%;width:${width.toFixed(2)}%;">
<div class="tooltip">
<div class="tooltip-row"><span class="tooltip-label">Start</span>${startTime}</div>
<div class="tooltip-row"><span class="tooltip-label">Stop</span>${endTime}</div>
<div class="tooltip-row"><span class="tooltip-label">Duration</span>${formatDuration(ev.duration)}</div>
<div class="tooltip-row"><span class="tooltip-label">Data</span>${JSON.stringify(ev.data)}</div>
</div></div>`;
        }
        html += `<tr${holClass}><td class="date">${dateCol}</td><td class="time">${timeCol}</td><td class="dur">${durCol}</td><td class="afk">${afkCol}</td><td class="timeline-cell"><div class="timeline"><div class="hour-marks">${hourMarks}</div>${eventBars}</div></td></tr>`;
    }
    table.innerHTML = html;
    document.querySelectorAll('.event').forEach(el => {
        const tooltip = el.querySelector('.tooltip');
        el.addEventListener('mouseenter', () => {
            tooltip.style.display = 'block';
            tooltip.style.top = '22px';
            tooltip.style.left = '0px';
            tooltip.style.right = 'auto';
            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) { tooltip.style.left = 'auto'; tooltip.style.right = '0px'; }
        });
        el.addEventListener('mouseleave', () => tooltip.style.display = 'none');
    });
}

function changeMonth(delta) {
    const input = document.getElementById('month');
    const [y, m] = input.value.split('-').map(Number);
    const d = new Date(y, m - 1 + delta, 1);
    input.value = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
    loadMonth(input.value);
}

// Settings dialog
function createSettingsDialog() {
    const overlay = document.createElement('div');
    overlay.className = 'settings-overlay';
    overlay.id = 'settings-overlay';
    overlay.innerHTML = `
        <div class="settings-dialog">
            <h3>設定</h3>
            <div class="field">
                <label class="field-check">
                    <input type="checkbox" id="s-no-colon">
                    コロンなし表示
                </label>
            </div>
            <div class="field">
                <span class="field-label">最小イベント秒数</span>
                <input type="number" id="s-min-event" min="0" step="1">
            </div>
            <div class="field">
                <span class="field-label">AFKバケット</span>
                <select id="s-bucket"><option value="">自動選択</option></select>
            </div>
            <div class="btn-row">
                <button id="s-cancel" class="btn-cancel">キャンセル</button>
                <button id="s-save" class="btn-save">保存</button>
            </div>
        </div>`;
    document.body.appendChild(overlay);
    document.getElementById('s-cancel').addEventListener('click', () => overlay.style.display = 'none');
    overlay.addEventListener('click', e => { if (e.target === overlay) overlay.style.display = 'none'; });
    document.getElementById('s-save').addEventListener('click', async () => {
        const body = {
            no_colon: document.getElementById('s-no-colon').checked,
            min_event_seconds: parseInt(document.getElementById('s-min-event').value, 10),
            bucket: document.getElementById('s-bucket').value || null
        };
        try {
            const res = await fetch('/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body)
            });
            const saved = await res.json();
            noColon = saved.no_colon;
            document.getElementById('noColon').checked = noColon;
            overlay.style.display = 'none';
            loadMonth(document.getElementById('month').value);
        } catch (e) {
            alert('設定の保存に失敗しました');
        }
    });
}

async function openSettings() {
    const overlay = document.getElementById('settings-overlay');
    overlay.style.display = 'block';
    try {
        const [settingsRes, bucketsRes] = await Promise.all([
            fetch('/settings'), fetch('/settings/buckets')
        ]);
        const settings = await settingsRes.json();
        const buckets = await bucketsRes.json();
        document.getElementById('s-no-colon').checked = settings.no_colon;
        document.getElementById('s-min-event').value = settings.min_event_seconds;
        const sel = document.getElementById('s-bucket');
        sel.innerHTML = '<option value="">自動選択</option>';
        for (const h of buckets) {
            const opt = document.createElement('option');
            opt.value = h;
            opt.textContent = h;
            if (settings.bucket === h) opt.selected = true;
            sel.appendChild(opt);
        }
    } catch (e) {
        // ignore load errors
    }
}

document.getElementById('prev').addEventListener('click', () => changeMonth(-1));
document.getElementById('next').addEventListener('click', () => changeMonth(1));
document.getElementById('month').addEventListener('change', e => loadMonth(e.target.value));
document.getElementById('noColon').addEventListener('change', e => {
    noColon = e.target.checked;
    loadMonth(document.getElementById('month').value);
});

createSettingsDialog();
document.getElementById('settings-btn').addEventListener('click', openSettings);

const now = new Date();
const initMonth = INIT_MONTH || `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
document.getElementById('month').value = initMonth;
document.getElementById('noColon').checked = INIT_NO_COLON;
loadMonth(initMonth);
</script>"""

    @classmethod
    def _script(cls, no_colon_js: str, min_event_js: str, init_month_js: str) -> str:
        return (
            cls._SCRIPT_TEMPLATE.replace("__NO_COLON_JS__", no_colon_js)
            .replace("__INIT_MIN_EVENT_JS__", min_event_js)
            .replace("__INIT_MONTH_JS__", init_month_js)
        )


# MARK: - CLI — エントリポイント
#
#  公開API: CLIMain.run()
#  依存: 全層


# MARK: CLIArgs


class CLIArgs:
    """コマンドライン引数"""

    def __init__(self) -> None:
        self._args: argparse.Namespace = self._parse()

    def _parse(self) -> argparse.Namespace:
        p: argparse.ArgumentParser = argparse.ArgumentParser(
            description="ActivityWatchから勤務時間をCSVにエクスポート",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog=self._epilog(),
        )
        p.add_argument(
            "--month",
            "-m",
            default="this",
            help="対象月: this(今月), last(先月), all(全期間), YYYY-MM",
        )
        p.add_argument("--output", "-o", help="出力ファイル名")
        p.add_argument("--quiet", "-q", action="store_true", help="進捗非表示")
        p.add_argument(
            "--no-colon", action="store_true", help="時刻をHHMMで出力（stdout時のみ）"
        )
        p.add_argument("--html", action="store_true", help="HTML形式でブラウザ表示")
        p.add_argument(
            "--bucket", "-b", help="使用するAFKバケットのPC名（例: Mac, PC-NAME.local）"
        )
        p.add_argument(
            "--min-event",
            type=int,
            default=None,
            help="最小イベント秒数（デフォルト: 150）",
        )
        return p.parse_args()

    _EPILOG: str = "\n".join(
        [
            "例:",
            "  aw-work-hours                    今月の勤務時間を出力",
            "  aw-work-hours --month=last       先月の勤務時間を出力",
            "  aw-work-hours --month=2025-11    2025年11月の勤務時間を出力",
            "  aw-work-hours --month=all        全期間の勤務時間を出力",
            "  aw-work-hours -o work.csv        ファイルに出力",
        ]
    )

    def _epilog(self) -> str:
        return self._EPILOG

    @property
    def month(self) -> str:
        return self._args.month

    @property
    def output(self) -> str | None:
        return self._args.output

    @property
    def quiet(self) -> bool:
        return self._args.quiet

    @property
    def no_colon(self) -> bool:
        return self._args.no_colon

    @property
    def html(self) -> bool:
        return self._args.html

    @property
    def bucket(self) -> str | None:
        return self._args.bucket

    @property
    def min_event(self) -> int | None:
        return self._args.min_event


# MARK: CLIOutput


class CLIOutput:
    """CLI出力処理"""

    def __init__(self, args: CLIArgs, settings: Settings) -> None:
        self._args: CLIArgs = args
        self._settings: Settings = settings

    def run(
        self, calendar: WorkCalendar, daily_work: DailyWork, period: MonthPeriod
    ) -> None:
        holidays: HolidayCalendar = HolidayCalendar()
        if self._args.output:
            self._write_csv(calendar, daily_work, period)
        else:
            self._print_text(calendar, daily_work, period, holidays)

    def _write_csv(
        self, calendar: WorkCalendar, daily_work: DailyWork, period: MonthPeriod
    ) -> None:
        csv: WorkCSV = WorkCSV(
            calendar.daily, daily_work.active, daily_work.gaps, period
        )
        output_abspath: str = self._args.output  # type: ignore[assignment]
        with open(output_abspath, "w", encoding="utf-8-sig") as f:
            f.write(csv.content())
        self._status(f"出力完了: {output_abspath}")

    def _print_text(
        self,
        calendar: WorkCalendar,
        daily_work: DailyWork,
        period: MonthPeriod,
        holidays: HolidayCalendar,
    ) -> None:
        text: WorkText = WorkText(
            calendar.daily,
            daily_work.active,
            daily_work.gaps,
            period,
            holidays,
            self._settings.no_colon,
        )
        print(text.content(), end="")

    def _status(self, msg: str) -> None:
        if not self._args.quiet:
            print(msg, file=sys.stderr)


# MARK: CLIMain


class CLIMain:
    """メインCLI処理"""

    def __init__(self) -> None:
        self._args: CLIArgs = CLIArgs()

    def run(self) -> None:
        try:
            settings: Settings = Settings()
            self._apply_args(settings)
            WorkRule.MIN_EVENT_SECONDS = settings.min_event_seconds
            AFKBucket.set_preference(settings.bucket)
            if self._args.html:
                self._run_html(settings)
            else:
                self._run_text(settings)
        except (CLIError, APIConnectionError) as e:
            print(str(e), file=sys.stderr)
            sys.exit(1)

    def _apply_args(self, settings: Settings) -> None:
        changed: bool = False
        if self._args.no_colon:
            settings.no_colon = True
            changed = True
        if self._args.min_event is not None:
            settings.min_event_seconds = self._args.min_event
            changed = True
        if self._args.bucket is not None:
            settings.bucket = self._args.bucket
            changed = True
        if changed:
            settings.save()

    def _run_html(self, settings: Settings) -> None:
        AFKBucket.id()
        init_month: str | None = self._resolve_init_month()
        html: str = WorkHTMLTemplate.render(settings, init_month)
        server: WorkHTTPServer = WorkHTTPServer()
        server.start(html, self._args.quiet)

    def _resolve_init_month(self) -> str | None:
        if self._args.month in ("this", "all"):
            return None
        dates: list[date] = MonthPeriod.parse(self._args.month).date_range()
        if dates:
            return f"{dates[0].year}-{dates[0].month:02d}"
        return None

    def _run_text(self, settings: Settings) -> None:
        period: MonthPeriod = MonthPeriod.parse(self._args.month)
        labels: dict[str, str] = {"all": "全期間", "this": "今月", "last": "先月"}
        self._status(f"対象期間: {labels.get(self._args.month, self._args.month)}")
        self._status("ActivityWatchからデータを取得中...")
        calendar, daily_work, events = WorkCalendar.from_period(period)
        self._status(f"取得イベント数: {len(events.raw)}")
        self._status(f"勤務日数: {calendar.days}")
        output: CLIOutput = CLIOutput(self._args, settings)
        output.run(calendar, daily_work, period)

    def _status(self, msg: str) -> None:
        if not self._args.quiet:
            print(msg, file=sys.stderr)


if __name__ == "__main__":
    CLIMain().run()
