#!/usr/bin/env python3
"""
ActivityWatchから日ごとの勤務時間をCSVにエクスポートするコマンド

Usage:
    aw-work-hours                    # 今月の勤務時間を出力
    aw-work-hours --month=last       # 先月の勤務時間を出力
    aw-work-hours --month=2025-11    # 2025年11月の勤務時間を出力
    aw-work-hours --month=all        # 全期間の勤務時間を出力

勤務日の判定ルール:
- 継続している勤務は何時までも同じ日として扱う
- 5:00-8:00の間に新たに開始した勤務は新しい日として扱う
- 24:00をまたいだ場合は26:00のような表記にする
"""

import argparse
import json
import sys
import urllib.request
import urllib.error
import urllib.parse
from datetime import datetime, timedelta, date
from zoneinfo import ZoneInfo

_API_BASE: str = "http://127.0.0.1:5600/api/0"
_BUCKET_ID: str = "aw-watcher-afk_PC-MC2408N0009B.local"
_TIMEZONE: ZoneInfo = ZoneInfo("Asia/Tokyo")
_WORK_GAP_SECONDS: int = 3 * 60 * 60
_WEEKDAYS: list[str] = ["月", "火", "水", "木", "金", "土", "日"]


class MonthPeriod:
    """月の期間"""

    def __init__(self, start: datetime | None, end: datetime | None) -> None:
        self._start: datetime | None = start
        self._end: datetime | None = end

    @classmethod
    def parse(cls, month_str: str) -> "MonthPeriod":
        now: datetime = datetime.now(_TIMEZONE)
        first: datetime = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)

        if month_str == "this":
            return cls._from_month(first, now.month, now.year)
        elif month_str == "last":
            prev_year: int = first.year - 1 if now.month == 1 else first.year
            prev_month: int = 12 if now.month == 1 else now.month - 1
            return cls._from_month(
                first.replace(year=prev_year, month=prev_month), prev_month, prev_year
            )
        elif month_str == "all":
            return cls(None, None)
        else:
            return cls._parse_yyyymm(month_str)

    @classmethod
    def _from_month(cls, start: datetime, month: int, year: int) -> "MonthPeriod":
        end: datetime = (
            start.replace(year=year + 1, month=1)
            if month == 12
            else start.replace(month=month + 1)
        )
        return cls(start, end)

    @classmethod
    def _parse_yyyymm(cls, month_str: str) -> "MonthPeriod":
        try:
            year, month = map(int, month_str.split("-"))
            start: datetime = datetime(year, month, 1, tzinfo=_TIMEZONE)
            return cls._from_month(start, month, year)
        except ValueError:
            print(f"エラー: 無効な月指定です: {month_str}", file=sys.stderr)
            print(
                "使用可能な形式: this, last, all, YYYY-MM (例: 2025-11)",
                file=sys.stderr,
            )
            sys.exit(1)

    @property
    def start(self) -> str | None:
        return self._start.isoformat() if self._start else None

    @property
    def end(self) -> str | None:
        return self._end.isoformat() if self._end else None

    @property
    def start_date(self) -> date | None:
        return self._start.date() if self._start else None

    @property
    def end_date(self) -> date | None:
        return self._end.date() if self._end else None


class AFKEvents:
    """ActivityWatchのAFKイベント"""

    def __init__(self, events: list[dict]) -> None:
        self._events: list[dict] = events

    @classmethod
    def fetch(cls, start: str | None, end: str | None) -> "AFKEvents":
        url: str = f"{_API_BASE}/buckets/{_BUCKET_ID}/events"
        params: dict[str, str] = {"limit": "-1"}
        if start:
            params["start"] = start
        if end:
            params["end"] = end
        url += "?" + urllib.parse.urlencode(params)

        try:
            with urllib.request.urlopen(url, timeout=30) as response:
                return cls(json.loads(response.read().decode()))
        except urllib.error.URLError as e:
            print("エラー: ActivityWatch APIに接続できません", file=sys.stderr)
            print("ActivityWatchが起動しているか確認してください", file=sys.stderr)
            print(f"詳細: {e}", file=sys.stderr)
            sys.exit(1)

    @property
    def count(self) -> int:
        return len(self._events)

    @property
    def work_blocks(self) -> list[tuple[datetime, datetime]]:
        not_afk: list[dict] = sorted(
            [e for e in self._events if e["data"]["status"] == "not-afk"],
            key=lambda e: e["timestamp"],
        )
        return self._extract_blocks(not_afk) if not_afk else []

    def _extract_blocks(self, events: list[dict]) -> list[tuple[datetime, datetime]]:
        blocks: list[tuple[datetime, datetime]] = []
        block_start: datetime | None = None
        block_end: datetime = datetime.min.replace(tzinfo=_TIMEZONE)

        for event in events:
            event_start: datetime = datetime.fromisoformat(
                event["timestamp"]
            ).astimezone(_TIMEZONE)
            event_end: datetime = event_start + timedelta(seconds=event["duration"])

            if block_start is None:
                block_start, block_end = event_start, event_end
            else:
                gap: float = (event_start - block_end).total_seconds()
                if gap > _WORK_GAP_SECONDS and event_start.hour >= 5:
                    blocks.append((block_start, block_end))
                    block_start, block_end = event_start, event_end
                else:
                    block_end = max(block_end, event_end)

        if block_start is not None:
            blocks.append((block_start, block_end))
        return blocks

    def daily_active_seconds(self) -> dict[date, float]:
        result: dict[date, float] = {}
        for event in self._not_afk_events():
            event_start: datetime = datetime.fromisoformat(
                event["timestamp"]
            ).astimezone(_TIMEZONE)
            wd: date = self._work_date(event_start)
            result[wd] = result.get(wd, 0) + event["duration"]
        return result

    def daily_max_gap_seconds(self) -> dict[date, float]:
        events_by_day: dict[date, list[tuple[datetime, datetime]]] = {}
        for event in self._not_afk_events():
            start: datetime = datetime.fromisoformat(event["timestamp"]).astimezone(
                _TIMEZONE
            )
            end: datetime = start + timedelta(seconds=event["duration"])
            wd: date = self._work_date(start)
            if wd not in events_by_day:
                events_by_day[wd] = []
            events_by_day[wd].append((start, end))
        return self._calc_max_gaps(events_by_day)

    def _calc_max_gaps(
        self, events_by_day: dict[date, list[tuple[datetime, datetime]]]
    ) -> dict[date, float]:
        result: dict[date, float] = {}
        for wd, events in events_by_day.items():
            sorted_events: list[tuple[datetime, datetime]] = sorted(events)
            max_gap: float = 0
            for i in range(1, len(sorted_events)):
                gap: float = (
                    sorted_events[i][0] - sorted_events[i - 1][1]
                ).total_seconds()
                max_gap = max(max_gap, gap)
            result[wd] = max_gap
        return result

    def _not_afk_events(self) -> list[dict]:
        return [e for e in self._events if e["data"]["status"] == "not-afk"]

    def _work_date(self, dt: datetime) -> date:
        return (dt - timedelta(days=1)).date() if 0 <= dt.hour < 5 else dt.date()


class WorkCalendar:
    """勤務カレンダー"""

    def __init__(
        self,
        daily: dict[date, tuple[datetime, datetime]],
        active: dict[date, float],
        max_gap: dict[date, float],
    ) -> None:
        self._daily: dict[date, tuple[datetime, datetime]] = daily
        self._active: dict[date, float] = active
        self._max_gap: dict[date, float] = max_gap

    @classmethod
    def from_blocks(
        cls,
        blocks: list[tuple[datetime, datetime]],
        active: dict[date, float],
        max_gap: dict[date, float],
    ) -> "WorkCalendar":
        daily: dict[date, tuple[datetime, datetime]] = {}
        for block_start, block_end in blocks:
            work_date: date = (
                (block_start - timedelta(days=1)).date()
                if 0 <= block_start.hour < 5
                else block_start.date()
            )
            if work_date not in daily:
                daily[work_date] = (block_start, block_end)
            else:
                s, e = daily[work_date]
                daily[work_date] = (min(block_start, s), max(block_end, e))
        return cls(daily, active, max_gap)

    @property
    def days(self) -> int:
        return len(self._daily)

    def csv(self) -> str:
        lines: list[str] = ["date,weekday,start_time,end_time,duration_hours"]
        for work_date in sorted(self._daily.keys()):
            start, end = self._daily[work_date]
            duration: float = (end - start).total_seconds() / 3600
            lines.append(
                f'="{work_date.strftime("%Y-%m-%d")}",{_WEEKDAYS[work_date.weekday()]},'
                f'="{self._format_time(start, work_date)}",="{self._format_time(end, work_date)}",{duration:.2f}'
            )
        return "\n".join(lines) + "\n"

    def compact(self, period: MonthPeriod) -> str:
        today: date = datetime.now(_TIMEZONE).date()
        if period.start_date and period.end_date:
            start: date = period.start_date
            end: date = min(period.end_date, today + timedelta(days=1))
        elif self._daily:
            start, end = min(self._daily.keys()), max(self._daily.keys()) + timedelta(
                days=1
            )
        else:
            return ""

        lines: list[str] = []
        current: date = start
        while current < end:
            lines.append(self._format_day(current))
            current += timedelta(days=1)
        return "\n".join(lines) + "\n" if lines else ""

    def _format_day(self, d: date) -> str:
        prefix: str = f'{d.strftime("%Y-%m-%d")} {_WEEKDAYS[d.weekday()]}'
        if d not in self._daily:
            return prefix
        s, e = self._daily[d]
        span: float = (e - s).total_seconds() / 3600
        if round(span, 1) == 0:
            return prefix
        active: float = self._active.get(d, 0) / 3600
        afk: float = span - active
        base: str = (
            f"{prefix}   {self._format_time(s, d)} - {self._format_time(e, d)}   ({span:.1f}h)"
        )
        if afk < 0.05:
            return base
        max_gap: float = self._max_gap.get(d, 0) / 3600
        return f"{base}   -{afk:.1f}h (max:-{max_gap:.1f}h)"

    def _format_time(self, dt: datetime, base: date) -> str:
        hour: int = dt.hour + ((dt.date() - base).days * 24)
        return f"{hour:02d}:{dt.minute:02d}"


class CLI:
    """コマンドラインインターフェース"""

    def run(self) -> None:
        args: argparse.Namespace = self._args()
        period: MonthPeriod = MonthPeriod.parse(args.month)
        labels: dict[str, str] = {"all": "全期間", "this": "今月", "last": "先月"}

        self._status(f"対象期間: {labels.get(args.month, args.month)}", args.quiet)
        self._status("ActivityWatchからデータを取得中...", args.quiet)

        events: AFKEvents = AFKEvents.fetch(period.start, period.end)
        self._status(f"取得イベント数: {events.count}", args.quiet)

        calendar: WorkCalendar = WorkCalendar.from_blocks(
            events.work_blocks,
            events.daily_active_seconds(),
            events.daily_max_gap_seconds(),
        )
        self._status(f"勤務日数: {calendar.days}", args.quiet)

        self._output(calendar, period, args)

    def _args(self) -> argparse.Namespace:
        p: argparse.ArgumentParser = argparse.ArgumentParser(
            description="ActivityWatchから勤務時間をCSVにエクスポート",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="例:\n  aw-work-hours                    今月の勤務時間を出力\n"
            "  aw-work-hours --month=last       先月の勤務時間を出力\n"
            "  aw-work-hours --month=2025-11    2025年11月の勤務時間を出力\n"
            "  aw-work-hours --month=all        全期間の勤務時間を出力\n"
            "  aw-work-hours -o work.csv        ファイルに出力",
        )
        p.add_argument(
            "--month",
            "-m",
            default="this",
            help="対象月: this(今月), last(先月), all(全期間), YYYY-MM",
        )
        p.add_argument("--output", "-o", help="出力ファイル名")
        p.add_argument("--quiet", "-q", action="store_true", help="進捗非表示")
        return p.parse_args()

    def _status(self, msg: str, quiet: bool) -> None:
        if not quiet:
            print(msg, file=sys.stderr)

    def _output(
        self, calendar: WorkCalendar, period: MonthPeriod, args: argparse.Namespace
    ) -> None:
        if args.output:
            with open(args.output, "w", encoding="utf-8-sig") as f:
                f.write(calendar.csv())
            self._status(f"出力完了: {args.output}", args.quiet)
        else:
            print(calendar.compact(period), end="")


if __name__ == "__main__":
    CLI().run()
